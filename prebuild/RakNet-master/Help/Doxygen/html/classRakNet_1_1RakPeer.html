<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RakNet: RakNet::RakPeer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RakNet
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRakNet.html">RakNet</a></li><li class="navelem"><a class="el" href="classRakNet_1_1RakPeer.html">RakPeer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRakNet_1_1RakPeer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RakNet::RakPeer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main interface for network communications.  
 <a href="classRakNet_1_1RakPeer.html#details">More...</a></p>

<p><code>#include &lt;RakPeer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RakNet::RakPeer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRakNet_1_1RakPeer.png" usemap="#RakNet::RakPeer_map" alt=""/>
  <map id="RakNet::RakPeer_map" name="RakNet::RakPeer_map">
<area href="classRakNet_1_1RakPeerInterface.html" title="The main interface for network communications." alt="RakNet::RakPeerInterface" shape="rect" coords="0,0,156,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac8368908e13e92fb7a2e080c7aa01a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac8368908e13e92fb7a2e080c7aa01a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aac8368908e13e92fb7a2e080c7aa01a7">RakPeer</a> ()</td></tr>
<tr class="memdesc:aac8368908e13e92fb7a2e080c7aa01a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:aac8368908e13e92fb7a2e080c7aa01a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5b944fb045c704771af32b314c2f14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed5b944fb045c704771af32b314c2f14"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aed5b944fb045c704771af32b314c2f14">~RakPeer</a> ()</td></tr>
<tr class="memdesc:aed5b944fb045c704771af32b314c2f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:aed5b944fb045c704771af32b314c2f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d493cb617381a6e750f7df6e768927"><td class="memItemLeft" align="right" valign="top">StartupResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927">Startup</a> (unsigned int maxConnections, <a class="el" href="structRakNet_1_1SocketDescriptor.html">SocketDescriptor</a> *socketDescriptors, unsigned socketDescriptorCount, int threadPriority=-99999)</td></tr>
<tr class="memdesc:a92d493cb617381a6e750f7df6e768927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the network threads and opens the listen port.  <a href="#a92d493cb617381a6e750f7df6e768927"></a><br/></td></tr>
<tr class="separator:a92d493cb617381a6e750f7df6e768927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5445d0e8db3e7ef1e38b7fc5bc0d3920"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a5445d0e8db3e7ef1e38b7fc5bc0d3920">InitializeSecurity</a> (const char *publicKey, const char *privateKey, bool bRequireClientKey=false)</td></tr>
<tr class="separator:a5445d0e8db3e7ef1e38b7fc5bc0d3920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489dd712e953836042df5711c8eb7e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a489dd712e953836042df5711c8eb7e76">DisableSecurity</a> (void)</td></tr>
<tr class="separator:a489dd712e953836042df5711c8eb7e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab927e4b0e70fcc0e06d1ba6a70315eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ab927e4b0e70fcc0e06d1ba6a70315eb3">AddToSecurityExceptionList</a> (const char *ip)</td></tr>
<tr class="memdesc:ab927e4b0e70fcc0e06d1ba6a70315eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is useful if you have a fixed-address internal server behind a LAN.  <a href="#ab927e4b0e70fcc0e06d1ba6a70315eb3"></a><br/></td></tr>
<tr class="separator:ab927e4b0e70fcc0e06d1ba6a70315eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931823b7400d31ad641d6f6da1e69b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a931823b7400d31ad641d6f6da1e69b88">RemoveFromSecurityExceptionList</a> (const char *ip)</td></tr>
<tr class="memdesc:a931823b7400d31ad641d6f6da1e69b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a specific connection previously added via AddToSecurityExceptionList.  <a href="#a931823b7400d31ad641d6f6da1e69b88"></a><br/></td></tr>
<tr class="separator:a931823b7400d31ad641d6f6da1e69b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654c29f6f195b0dcd105a856c99222d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a654c29f6f195b0dcd105a856c99222d1">IsInSecurityExceptionList</a> (const char *ip)</td></tr>
<tr class="memdesc:a654c29f6f195b0dcd105a856c99222d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a given IP is in the security exception list.  <a href="#a654c29f6f195b0dcd105a856c99222d1"></a><br/></td></tr>
<tr class="separator:a654c29f6f195b0dcd105a856c99222d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed81856dd81ec1cd00e17fafedee0a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a8ed81856dd81ec1cd00e17fafedee0a7">SetMaximumIncomingConnections</a> (unsigned short numberAllowed)</td></tr>
<tr class="memdesc:a8ed81856dd81ec1cd00e17fafedee0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of incoming connections allowed.  <a href="#a8ed81856dd81ec1cd00e17fafedee0a7"></a><br/></td></tr>
<tr class="separator:a8ed81856dd81ec1cd00e17fafedee0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eac8d486bbcb12e350c49c43c92618"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a21eac8d486bbcb12e350c49c43c92618">GetMaximumIncomingConnections</a> (void) const </td></tr>
<tr class="memdesc:a21eac8d486bbcb12e350c49c43c92618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value passed to <a class="el" href="classRakNet_1_1RakPeer.html#a8ed81856dd81ec1cd00e17fafedee0a7" title="Sets the maximum number of incoming connections allowed.">SetMaximumIncomingConnections()</a>.  <a href="#a21eac8d486bbcb12e350c49c43c92618"></a><br/></td></tr>
<tr class="separator:a21eac8d486bbcb12e350c49c43c92618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d47b849ba6e7ecf2d1fca3198a60ba5"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a4d47b849ba6e7ecf2d1fca3198a60ba5">NumberOfConnections</a> (void) const </td></tr>
<tr class="memdesc:a4d47b849ba6e7ecf2d1fca3198a60ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many open connections exist at this time.  <a href="#a4d47b849ba6e7ecf2d1fca3198a60ba5"></a><br/></td></tr>
<tr class="separator:a4d47b849ba6e7ecf2d1fca3198a60ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4071bbbf128604c94a27c46fa7b9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a6d4071bbbf128604c94a27c46fa7b9ce">SetIncomingPassword</a> (const char *passwordData, int passwordDataLength)</td></tr>
<tr class="memdesc:a6d4071bbbf128604c94a27c46fa7b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the password for the incoming connections.  <a href="#a6d4071bbbf128604c94a27c46fa7b9ce"></a><br/></td></tr>
<tr class="separator:a6d4071bbbf128604c94a27c46fa7b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395e269dce0de14f22bfb870923f22b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a395e269dce0de14f22bfb870923f22b3">GetIncomingPassword</a> (char *passwordData, int *passwordDataLength)</td></tr>
<tr class="memdesc:a395e269dce0de14f22bfb870923f22b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the password passed to SetIncomingPassword.  <a href="#a395e269dce0de14f22bfb870923f22b3"></a><br/></td></tr>
<tr class="separator:a395e269dce0de14f22bfb870923f22b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19979ff2acc15abe22785fc55c1c656c"><td class="memItemLeft" align="right" valign="top">ConnectionAttemptResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a19979ff2acc15abe22785fc55c1c656c">Connect</a> (const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, <a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *publicKey=0, unsigned connectionSocketIndex=0, unsigned sendConnectionAttemptCount=6, unsigned timeBetweenSendConnectionAttemptsMS=1000, RakNet::TimeMS timeoutTime=0)</td></tr>
<tr class="memdesc:a19979ff2acc15abe22785fc55c1c656c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the specified host (ip or domain name) and server port.  <a href="#a19979ff2acc15abe22785fc55c1c656c"></a><br/></td></tr>
<tr class="separator:a19979ff2acc15abe22785fc55c1c656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8852b99f2d8919bee57fd457477292a0"><td class="memItemLeft" align="right" valign="top">virtual ConnectionAttemptResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a8852b99f2d8919bee57fd457477292a0">ConnectWithSocket</a> (const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, RakNetSocket2 *socket, <a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *publicKey=0, unsigned sendConnectionAttemptCount=6, unsigned timeBetweenSendConnectionAttemptsMS=1000, RakNet::TimeMS timeoutTime=0)</td></tr>
<tr class="memdesc:a8852b99f2d8919bee57fd457477292a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the specified host (ip or domain name) and server port.  <a href="#a8852b99f2d8919bee57fd457477292a0"></a><br/></td></tr>
<tr class="separator:a8852b99f2d8919bee57fd457477292a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6d4c16c9b489574393a39ab2f99990"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a0a6d4c16c9b489574393a39ab2f99990">Shutdown</a> (unsigned int blockDuration, unsigned char orderingChannel=0, <a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority=<a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705cadb8ee22a232a2787f32ba28da55c43c1">LOW_PRIORITY</a>)</td></tr>
<tr class="memdesc:a0a6d4c16c9b489574393a39ab2f99990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the network threads and closes all connections.  <a href="#a0a6d4c16c9b489574393a39ab2f99990"></a><br/></td></tr>
<tr class="separator:a0a6d4c16c9b489574393a39ab2f99990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bb2c4de0b24283b231154d29304e00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ae6bb2c4de0b24283b231154d29304e00">IsActive</a> (void) const </td></tr>
<tr class="memdesc:ae6bb2c4de0b24283b231154d29304e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the network thread is running.  <a href="#ae6bb2c4de0b24283b231154d29304e00"></a><br/></td></tr>
<tr class="separator:ae6bb2c4de0b24283b231154d29304e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af5b69face182410f2abb11da902dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a0af5b69face182410f2abb11da902dd4">GetConnectionList</a> (<a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> *remoteSystems, unsigned short *numberOfSystems) const </td></tr>
<tr class="memdesc:a0af5b69face182410f2abb11da902dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the array remoteSystems with the <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> of all the systems we are connected to.  <a href="#a0af5b69face182410f2abb11da902dd4"></a><br/></td></tr>
<tr class="separator:a0af5b69face182410f2abb11da902dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6e283f476bdd4ed8b9b4c56693ecd1"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a1d6e283f476bdd4ed8b9b4c56693ecd1">GetNextSendReceipt</a> (void)</td></tr>
<tr class="separator:a1d6e283f476bdd4ed8b9b4c56693ecd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9232bd1bc9c1a223ecef8682133f95ac"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a9232bd1bc9c1a223ecef8682133f95ac">IncrementNextSendReceipt</a> (void)</td></tr>
<tr class="separator:a9232bd1bc9c1a223ecef8682133f95ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee7422f744ab606c92b4ed4b28db40e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a1ee7422f744ab606c92b4ed4b28db40e">Send</a> (const char *data, const int length, <a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#ae41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)</td></tr>
<tr class="memdesc:a1ee7422f744ab606c92b4ed4b28db40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a block of data to the specified system that you are connected to.  <a href="#a1ee7422f744ab606c92b4ed4b28db40e"></a><br/></td></tr>
<tr class="separator:a1ee7422f744ab606c92b4ed4b28db40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f1dcedc63156184962aa184ba69ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ac3f1dcedc63156184962aa184ba69ed2">SendLoopback</a> (const char *data, const int length)</td></tr>
<tr class="memdesc:ac3f1dcedc63156184962aa184ba69ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Send" to yourself rather than a remote system.  <a href="#ac3f1dcedc63156184962aa184ba69ed2"></a><br/></td></tr>
<tr class="separator:ac3f1dcedc63156184962aa184ba69ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac308204d9c3f5f92ac11b30f1d183d4b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ac308204d9c3f5f92ac11b30f1d183d4b">Send</a> (const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#ae41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)</td></tr>
<tr class="memdesc:ac308204d9c3f5f92ac11b30f1d183d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a block of data to the specified system that you are connected to.  <a href="#ac308204d9c3f5f92ac11b30f1d183d4b"></a><br/></td></tr>
<tr class="separator:ac308204d9c3f5f92ac11b30f1d183d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a9c6f4db253074f3775d164e39195f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a68a9c6f4db253074f3775d164e39195f">SendList</a> (const char **data, const int *lengths, const int numParameters, <a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#ae41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)</td></tr>
<tr class="memdesc:a68a9c6f4db253074f3775d164e39195f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends multiple blocks of data, concatenating them automatically.  <a href="#a68a9c6f4db253074f3775d164e39195f"></a><br/></td></tr>
<tr class="separator:a68a9c6f4db253074f3775d164e39195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d90fb903e747f76d63eb3a96543740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740">Receive</a> (void)</td></tr>
<tr class="memdesc:a46d90fb903e747f76d63eb3a96543740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a message from the incoming message queue.  <a href="#a46d90fb903e747f76d63eb3a96543740"></a><br/></td></tr>
<tr class="separator:a46d90fb903e747f76d63eb3a96543740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e053f8f77d9b2e7b7fcd03f8f9120e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ae3e053f8f77d9b2e7b7fcd03f8f9120e">DeallocatePacket</a> (<a class="el" href="structRakNet_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ae3e053f8f77d9b2e7b7fcd03f8f9120e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to deallocate a message returned by <a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740" title="Gets a message from the incoming message queue.">Receive()</a> when you are done handling it.  <a href="#ae3e053f8f77d9b2e7b7fcd03f8f9120e"></a><br/></td></tr>
<tr class="separator:ae3e053f8f77d9b2e7b7fcd03f8f9120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1743ff40a69e0362cdb483d88b801b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#abd1743ff40a69e0362cdb483d88b801b">GetMaximumNumberOfPeers</a> (void) const </td></tr>
<tr class="memdesc:abd1743ff40a69e0362cdb483d88b801b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of connections we are allowed.  <a href="#abd1743ff40a69e0362cdb483d88b801b"></a><br/></td></tr>
<tr class="separator:abd1743ff40a69e0362cdb483d88b801b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e3806fce8552e322236abcf105cbf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a95e3806fce8552e322236abcf105cbf9">CloseConnection</a> (const AddressOrGUID target, bool sendDisconnectionNotification, unsigned char orderingChannel=0, <a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority=<a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705cadb8ee22a232a2787f32ba28da55c43c1">LOW_PRIORITY</a>)</td></tr>
<tr class="memdesc:a95e3806fce8552e322236abcf105cbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out).  <a href="#a95e3806fce8552e322236abcf105cbf9"></a><br/></td></tr>
<tr class="separator:a95e3806fce8552e322236abcf105cbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f934680b37ffbfdc0047ac406fc2512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a5f934680b37ffbfdc0047ac406fc2512">CancelConnectionAttempt</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)</td></tr>
<tr class="memdesc:a5f934680b37ffbfdc0047ac406fc2512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending connection attempt.  <a href="#a5f934680b37ffbfdc0047ac406fc2512"></a><br/></td></tr>
<tr class="separator:a5f934680b37ffbfdc0047ac406fc2512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514c8d6f1dc75b5e9bb3cb5b9dcb632b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRakNet.html#a84a0fb005391f71130dd341f77f62138">ConnectionState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a514c8d6f1dc75b5e9bb3cb5b9dcb632b">GetConnectionState</a> (const AddressOrGUID systemIdentifier)</td></tr>
<tr class="separator:a514c8d6f1dc75b5e9bb3cb5b9dcb632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77373ffe92c37f01b39bc16c62ac9ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ad77373ffe92c37f01b39bc16c62ac9ba">GetIndexFromSystemAddress</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress) const </td></tr>
<tr class="memdesc:ad77373ffe92c37f01b39bc16c62ac9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <em>systemAddress</em>, returns its index into remoteSystemList.  <a href="#ad77373ffe92c37f01b39bc16c62ac9ba"></a><br/></td></tr>
<tr class="separator:ad77373ffe92c37f01b39bc16c62ac9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3159d6eabc0a1a4298fb67c7fc7146b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aa3159d6eabc0a1a4298fb67c7fc7146b">GetSystemAddressFromIndex</a> (unsigned int index)</td></tr>
<tr class="memdesc:aa3159d6eabc0a1a4298fb67c7fc7146b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <em>index</em> into remoteSystemList, will return a <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a>. This function is only useful for looping through all systems.  <a href="#aa3159d6eabc0a1a4298fb67c7fc7146b"></a><br/></td></tr>
<tr class="separator:aa3159d6eabc0a1a4298fb67c7fc7146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab639b98f7b007833b08930de45545433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ab639b98f7b007833b08930de45545433">GetGUIDFromIndex</a> (unsigned int index)</td></tr>
<tr class="memdesc:ab639b98f7b007833b08930de45545433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as GetSystemAddressFromIndex but returns <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>.  <a href="#ab639b98f7b007833b08930de45545433"></a><br/></td></tr>
<tr class="separator:ab639b98f7b007833b08930de45545433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791779bb9714e830f19a5f12961576d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a791779bb9714e830f19a5f12961576d7">GetSystemList</a> (<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &gt; &amp;addresses, <a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &gt; &amp;guids) const </td></tr>
<tr class="memdesc:a791779bb9714e830f19a5f12961576d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as calling GetSystemAddressFromIndex and GetGUIDFromIndex for all systems, but more efficient Indices match each other, so <em>addresses</em>[0] and <em>guids</em>[0] refer to the same system.  <a href="#a791779bb9714e830f19a5f12961576d7"></a><br/></td></tr>
<tr class="separator:a791779bb9714e830f19a5f12961576d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad403c131efe8bfe6f3c5280e110b9b2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ad403c131efe8bfe6f3c5280e110b9b2d">AddToBanList</a> (const char *IP, RakNet::TimeMS milliseconds=0)</td></tr>
<tr class="memdesc:ad403c131efe8bfe6f3c5280e110b9b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bans an IP from connecting.  <a href="#ad403c131efe8bfe6f3c5280e110b9b2d"></a><br/></td></tr>
<tr class="separator:ad403c131efe8bfe6f3c5280e110b9b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c426318efc45345df9a348ae822f34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86c426318efc45345df9a348ae822f34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a86c426318efc45345df9a348ae822f34">RemoveFromBanList</a> (const char *IP)</td></tr>
<tr class="memdesc:a86c426318efc45345df9a348ae822f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a previously banned IP to connect. param[in] Dotted IP address. You can use * as a wildcard. An IP such as 128.0.0.* will ban all IP addresses starting with 128.0.0. <br/></td></tr>
<tr class="separator:a86c426318efc45345df9a348ae822f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a3cfa151c1facf78fd835d8bc620dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a3cfa151c1facf78fd835d8bc620dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#af2a3cfa151c1facf78fd835d8bc620dc">ClearBanList</a> (void)</td></tr>
<tr class="memdesc:af2a3cfa151c1facf78fd835d8bc620dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows all previously banned IPs to connect. <br/></td></tr>
<tr class="separator:af2a3cfa151c1facf78fd835d8bc620dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499626110e1409b09e7d955722c4c3fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a499626110e1409b09e7d955722c4c3fd">IsBanned</a> (const char *IP)</td></tr>
<tr class="memdesc:a499626110e1409b09e7d955722c4c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true or false indicating if a particular IP is banned.  <a href="#a499626110e1409b09e7d955722c4c3fd"></a><br/></td></tr>
<tr class="separator:a499626110e1409b09e7d955722c4c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e80ab105ac8124d4ee5f94bd1b316a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ac5e80ab105ac8124d4ee5f94bd1b316a">SetLimitIPConnectionFrequency</a> (bool b)</td></tr>
<tr class="memdesc:ac5e80ab105ac8124d4ee5f94bd1b316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable allowing frequent connections from the same IP adderss.  <a href="#ac5e80ab105ac8124d4ee5f94bd1b316a"></a><br/></td></tr>
<tr class="separator:ac5e80ab105ac8124d4ee5f94bd1b316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb94828e0ad89e0d6c44a671bf22f8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a9bb94828e0ad89e0d6c44a671bf22f8d">Ping</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)</td></tr>
<tr class="separator:a9bb94828e0ad89e0d6c44a671bf22f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dd13a4c3d38e65bf816a604c6042c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#af7dd13a4c3d38e65bf816a604c6042c7">Ping</a> (const char *host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections, unsigned connectionSocketIndex=0)</td></tr>
<tr class="memdesc:af7dd13a4c3d38e65bf816a604c6042c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a ping to the specified unconnected system.  <a href="#af7dd13a4c3d38e65bf816a604c6042c7"></a><br/></td></tr>
<tr class="separator:af7dd13a4c3d38e65bf816a604c6042c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b735d6075d64dcdf5c554989f4a5f98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a2b735d6075d64dcdf5c554989f4a5f98">GetAveragePing</a> (const AddressOrGUID systemIdentifier)</td></tr>
<tr class="memdesc:a2b735d6075d64dcdf5c554989f4a5f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the average of all ping times read for the specific system or -1 if none read yet.  <a href="#a2b735d6075d64dcdf5c554989f4a5f98"></a><br/></td></tr>
<tr class="separator:a2b735d6075d64dcdf5c554989f4a5f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a21e884778d65fb4493b29e5c1826c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a7a21e884778d65fb4493b29e5c1826c5">GetLastPing</a> (const AddressOrGUID systemIdentifier) const </td></tr>
<tr class="memdesc:a7a21e884778d65fb4493b29e5c1826c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last ping time read for the specific system or -1 if none read yet.  <a href="#a7a21e884778d65fb4493b29e5c1826c5"></a><br/></td></tr>
<tr class="separator:a7a21e884778d65fb4493b29e5c1826c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8673a54a5f3926ac93e13a4a20367"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#afdb8673a54a5f3926ac93e13a4a20367">GetLowestPing</a> (const AddressOrGUID systemIdentifier) const </td></tr>
<tr class="memdesc:afdb8673a54a5f3926ac93e13a4a20367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest ping time read or -1 if none read yet.  <a href="#afdb8673a54a5f3926ac93e13a4a20367"></a><br/></td></tr>
<tr class="separator:afdb8673a54a5f3926ac93e13a4a20367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8d47e41f9bc523a555d8f1bc774e4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#abb8d47e41f9bc523a555d8f1bc774e4a">SetOccasionalPing</a> (bool doPing)</td></tr>
<tr class="separator:abb8d47e41f9bc523a555d8f1bc774e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f87a029e47963ae24838ec87c1a076"><td class="memItemLeft" align="right" valign="top">RakNet::Time&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ac1f87a029e47963ae24838ec87c1a076">GetClockDifferential</a> (const AddressOrGUID systemIdentifier)</td></tr>
<tr class="separator:ac1f87a029e47963ae24838ec87c1a076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a534f1c0bb56b3c5b9b56ca8839917c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a2a534f1c0bb56b3c5b9b56ca8839917c">SetOfflinePingResponse</a> (const char *data, const unsigned int length)</td></tr>
<tr class="memdesc:a2a534f1c0bb56b3c5b9b56ca8839917c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data to send along with a LAN server discovery or offline ping reply.  <a href="#a2a534f1c0bb56b3c5b9b56ca8839917c"></a><br/></td></tr>
<tr class="separator:a2a534f1c0bb56b3c5b9b56ca8839917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec33659d51a00eed12bd1dc8a24071b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aec33659d51a00eed12bd1dc8a24071b0">GetOfflinePingResponse</a> (char **data, unsigned int *length)</td></tr>
<tr class="memdesc:aec33659d51a00eed12bd1dc8a24071b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointers to a copy of the <em>data</em> passed to SetOfflinePingResponse.  <a href="#aec33659d51a00eed12bd1dc8a24071b0"></a><br/></td></tr>
<tr class="separator:aec33659d51a00eed12bd1dc8a24071b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82a248aa543c9ec04567c14004fea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#acf82a248aa543c9ec04567c14004fea5">GetInternalID</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress=<a class="el" href="namespaceRakNet.html#a80c95b4ed53f42911a6fa92b85e929cf">UNASSIGNED_SYSTEM_ADDRESS</a>, const int index=0) const </td></tr>
<tr class="memdesc:acf82a248aa543c9ec04567c14004fea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique address identifier that represents you or another system on the the network.  <a href="#acf82a248aa543c9ec04567c14004fea5"></a><br/></td></tr>
<tr class="separator:acf82a248aa543c9ec04567c14004fea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02c3a4e4c4063771fb47fe20d4b47af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ad02c3a4e4c4063771fb47fe20d4b47af">SetInternalID</a> (<a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress, int index=0)</td></tr>
<tr class="memdesc:ad02c3a4e4c4063771fb47fe20d4b47af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets your internal IP address, for platforms that do not support reading it, or to override a value.  <a href="#ad02c3a4e4c4063771fb47fe20d4b47af"></a><br/></td></tr>
<tr class="separator:ad02c3a4e4c4063771fb47fe20d4b47af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f0e923c413fe2319d17862605d6622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a96f0e923c413fe2319d17862605d6622">GetExternalID</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target) const </td></tr>
<tr class="memdesc:a96f0e923c413fe2319d17862605d6622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique address identifier that represents the target on the the network and is based on the target's external IP / port.  <a href="#a96f0e923c413fe2319d17862605d6622"></a><br/></td></tr>
<tr class="separator:a96f0e923c413fe2319d17862605d6622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa1d1f5b3227506bb827e722cfb78fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fa1d1f5b3227506bb827e722cfb78fa"></a>
const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a3fa1d1f5b3227506bb827e722cfb78fa">GetMyGUID</a> (void) const </td></tr>
<tr class="memdesc:a3fa1d1f5b3227506bb827e722cfb78fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return my own GUID. <br/></td></tr>
<tr class="separator:a3fa1d1f5b3227506bb827e722cfb78fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1566deab65341e8b665f7643b3a3bcf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1566deab65341e8b665f7643b3a3bcf9"></a>
<a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a1566deab65341e8b665f7643b3a3bcf9">GetMyBoundAddress</a> (const int socketIndex=0)</td></tr>
<tr class="memdesc:a1566deab65341e8b665f7643b3a3bcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address bound to a socket at the specified index. <br/></td></tr>
<tr class="separator:a1566deab65341e8b665f7643b3a3bcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fcd1175cb8fee67b12835944ed51da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a41fcd1175cb8fee67b12835944ed51da">GetGuidFromSystemAddress</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> input) const </td></tr>
<tr class="memdesc:a41fcd1175cb8fee67b12835944ed51da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a connected system address, this method gives the unique GUID representing that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>. This will be the same on all systems connected to that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Complexity is O(log2(n)). If <em>input</em> is UNASSIGNED_SYSTEM_ADDRESS, will return your own GUID.  <a href="#a41fcd1175cb8fee67b12835944ed51da"></a><br/></td></tr>
<tr class="separator:a41fcd1175cb8fee67b12835944ed51da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac591b0ac4b88b9cdf182fc4769d9de98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ac591b0ac4b88b9cdf182fc4769d9de98">GetSystemAddressFromGuid</a> (const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> input) const </td></tr>
<tr class="memdesc:ac591b0ac4b88b9cdf182fc4769d9de98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the system address of a connected system, given its GUID. The GUID will be the same on all systems connected to that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Currently O(log(n)), but this may be improved in the future If <em>input</em> is UNASSIGNED_RAKNET_GUID, UNASSIGNED_SYSTEM_ADDRESS is returned.  <a href="#ac591b0ac4b88b9cdf182fc4769d9de98"></a><br/></td></tr>
<tr class="separator:ac591b0ac4b88b9cdf182fc4769d9de98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc607f77d9724097030d2da6868074b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#abc607f77d9724097030d2da6868074b3">GetClientPublicKeyFromSystemAddress</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> input, char *client_public_key) const </td></tr>
<tr class="separator:abc607f77d9724097030d2da6868074b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46305b16342c6f5ec1c1a66623032310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a46305b16342c6f5ec1c1a66623032310">SetTimeoutTime</a> (RakNet::TimeMS timeMS, const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)</td></tr>
<tr class="memdesc:a46305b16342c6f5ec1c1a66623032310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time, in MS, to use before considering ourselves disconnected after not being able to deliver a reliable message.  <a href="#a46305b16342c6f5ec1c1a66623032310"></a><br/></td></tr>
<tr class="separator:a46305b16342c6f5ec1c1a66623032310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc51372f2a5a109f3c6a55ba799763"><td class="memItemLeft" align="right" valign="top">RakNet::TimeMS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a12dc51372f2a5a109f3c6a55ba799763">GetTimeoutTime</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)</td></tr>
<tr class="memdesc:a12dc51372f2a5a109f3c6a55ba799763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Timeout time for the given system.  <a href="#a12dc51372f2a5a109f3c6a55ba799763"></a><br/></td></tr>
<tr class="separator:a12dc51372f2a5a109f3c6a55ba799763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5948dcad656f51305ed20c8b38e529b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#af5948dcad656f51305ed20c8b38e529b">GetMTUSize</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target) const </td></tr>
<tr class="memdesc:af5948dcad656f51305ed20c8b38e529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current MTU size.  <a href="#af5948dcad656f51305ed20c8b38e529b"></a><br/></td></tr>
<tr class="separator:af5948dcad656f51305ed20c8b38e529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca51c8583f3995217a940bf592d7140c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aca51c8583f3995217a940bf592d7140c">GetNumberOfAddresses</a> (void)</td></tr>
<tr class="memdesc:aca51c8583f3995217a940bf592d7140c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of IP addresses this system has internally.  <a href="#aca51c8583f3995217a940bf592d7140c"></a><br/></td></tr>
<tr class="separator:aca51c8583f3995217a940bf592d7140c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78c5de86816a54cae137bffb7e49bc5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aa78c5de86816a54cae137bffb7e49bc5">GetLocalIP</a> (unsigned int index)</td></tr>
<tr class="separator:aa78c5de86816a54cae137bffb7e49bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89d80f939408a620a5e41eeab0a588a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ad89d80f939408a620a5e41eeab0a588a">IsLocalIP</a> (const char *ip)</td></tr>
<tr class="separator:ad89d80f939408a620a5e41eeab0a588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b24a4946b34071621b0b288b869f21f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a3b24a4946b34071621b0b288b869f21f">AllowConnectionResponseIPMigration</a> (bool allow)</td></tr>
<tr class="memdesc:a3b24a4946b34071621b0b288b869f21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or disallow connection responses from any IP.  <a href="#a3b24a4946b34071621b0b288b869f21f"></a><br/></td></tr>
<tr class="separator:a3b24a4946b34071621b0b288b869f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0396cdb296a5df8b8266c8cce138d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aecb0396cdb296a5df8b8266c8cce138d">AdvertiseSystem</a> (const char *host, unsigned short remotePort, const char *data, int dataLength, unsigned connectionSocketIndex=0)</td></tr>
<tr class="memdesc:aecb0396cdb296a5df8b8266c8cce138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system. This will send our external IP outside the LAN along with some user data to the remote system.  <a href="#aecb0396cdb296a5df8b8266c8cce138d"></a><br/></td></tr>
<tr class="separator:aecb0396cdb296a5df8b8266c8cce138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e89d9813d6f6e7f2144a6a0437a33b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a35e89d9813d6f6e7f2144a6a0437a33b">SetSplitMessageProgressInterval</a> (int interval)</td></tr>
<tr class="memdesc:a35e89d9813d6f6e7f2144a6a0437a33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads.  <a href="#a35e89d9813d6f6e7f2144a6a0437a33b"></a><br/></td></tr>
<tr class="separator:a35e89d9813d6f6e7f2144a6a0437a33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f01256eab673794028fe48980ef6fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#af9f01256eab673794028fe48980ef6fa">GetSplitMessageProgressInterval</a> (void) const </td></tr>
<tr class="memdesc:af9f01256eab673794028fe48980ef6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns what was passed to <a class="el" href="classRakNet_1_1RakPeer.html#a35e89d9813d6f6e7f2144a6a0437a33b" title="Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads.">SetSplitMessageProgressInterval()</a>.  <a href="#af9f01256eab673794028fe48980ef6fa"></a><br/></td></tr>
<tr class="separator:af9f01256eab673794028fe48980ef6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739faf1ea8c90aded5e11bfc105b956e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a739faf1ea8c90aded5e11bfc105b956e">SetUnreliableTimeout</a> (RakNet::TimeMS timeoutMS)</td></tr>
<tr class="memdesc:a739faf1ea8c90aded5e11bfc105b956e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how long to wait before giving up on sending an unreliable message. Useful if the network is clogged up. Set to 0 or less to never timeout. Defaults to 0.  <a href="#a739faf1ea8c90aded5e11bfc105b956e"></a><br/></td></tr>
<tr class="separator:a739faf1ea8c90aded5e11bfc105b956e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b8b2a8d2e4edc2c1d89f6bde8b9f28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a86b8b2a8d2e4edc2c1d89f6bde8b9f28">SendTTL</a> (const char *host, unsigned short remotePort, int ttl, unsigned connectionSocketIndex=0)</td></tr>
<tr class="memdesc:a86b8b2a8d2e4edc2c1d89f6bde8b9f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to a host, with the IP socket option TTL set to 3.  <a href="#a86b8b2a8d2e4edc2c1d89f6bde8b9f28"></a><br/></td></tr>
<tr class="separator:a86b8b2a8d2e4edc2c1d89f6bde8b9f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceacd63ae51089a2e36287c54f07ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a4ceacd63ae51089a2e36287c54f07ffe">AttachPlugin</a> (<a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *plugin)</td></tr>
<tr class="memdesc:a4ceacd63ae51089a2e36287c54f07ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a Plugin interface to an instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) to run code automatically on message receipt in the Receive call. If the plugin returns false from PluginInterface::UsesReliabilityLayer(), which is the case for all plugins except <a class="el" href="classRakNet_1_1PacketLogger.html" title="Writes incoming and outgoing messages to the screen. This will write all incoming and outgoing messag...">PacketLogger</a>, you can call <a class="el" href="classRakNet_1_1RakPeer.html#a4ceacd63ae51089a2e36287c54f07ffe" title="Attaches a Plugin interface to an instance of the base class (RakPeer or PacketizedTCP) to run code a...">AttachPlugin()</a> and <a class="el" href="classRakNet_1_1RakPeer.html#a9f29151642a0ad0abdddc6d9a8f25239" title="Detaches a Plugin interface from the instance of the base class (RakPeer or PacketizedTCP) it is atta...">DetachPlugin()</a> for this plugin while <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> is active.  <a href="#a4ceacd63ae51089a2e36287c54f07ffe"></a><br/></td></tr>
<tr class="separator:a4ceacd63ae51089a2e36287c54f07ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f29151642a0ad0abdddc6d9a8f25239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a9f29151642a0ad0abdddc6d9a8f25239">DetachPlugin</a> (<a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *messageHandler)</td></tr>
<tr class="memdesc:a9f29151642a0ad0abdddc6d9a8f25239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a Plugin interface from the instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) it is attached to.  <a href="#a9f29151642a0ad0abdddc6d9a8f25239"></a><br/></td></tr>
<tr class="separator:a9f29151642a0ad0abdddc6d9a8f25239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f687f4bbd396e326be77ac1fa77a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ac32f687f4bbd396e326be77ac1fa77a8">PushBackPacket</a> (<a class="el" href="structRakNet_1_1Packet.html">Packet</a> *packet, bool pushAtHead)</td></tr>
<tr class="memdesc:ac32f687f4bbd396e326be77ac1fa77a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a message back in the receive queue in case you don't want to deal with it immediately.  <a href="#ac32f687f4bbd396e326be77ac1fa77a8"></a><br/></td></tr>
<tr class="separator:ac32f687f4bbd396e326be77ac1fa77a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be8b42a06fdd32f29f032ba5fc5e7b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a5be8b42a06fdd32f29f032ba5fc5e7b0">AllocatePacket</a> (unsigned dataSize)</td></tr>
<tr class="memdesc:a5be8b42a06fdd32f29f032ba5fc5e7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a packet for you to write to if you want to create a <a class="el" href="structRakNet_1_1Packet.html" title="This represents a user message from another system.">Packet</a> for some reason. You can add it to the receive buffer with PushBackPacket.  <a href="#a5be8b42a06fdd32f29f032ba5fc5e7b0"></a><br/></td></tr>
<tr class="separator:a5be8b42a06fdd32f29f032ba5fc5e7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69ef5d63339d36dc99b905586a23151"><td class="memItemLeft" align="right" valign="top">virtual RakNetSocket2 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ab69ef5d63339d36dc99b905586a23151">GetSocket</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)</td></tr>
<tr class="memdesc:ab69ef5d63339d36dc99b905586a23151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket used with a particular active connection. The smart pointer reference counts the RakNetSocket object, so the socket will remain active as long as the smart pointer does, even if <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher that can be used f...">RakNet</a> were to shutdown or close the connection.  <a href="#ab69ef5d63339d36dc99b905586a23151"></a><br/></td></tr>
<tr class="separator:ab69ef5d63339d36dc99b905586a23151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c353846b88cb39d4c8d12ba4f5ca42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a35c353846b88cb39d4c8d12ba4f5ca42">GetSockets</a> (<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; RakNetSocket2 * &gt; &amp;sockets)</td></tr>
<tr class="memdesc:a35c353846b88cb39d4c8d12ba4f5ca42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all sockets in use.  <a href="#a35c353846b88cb39d4c8d12ba4f5ca42"></a><br/></td></tr>
<tr class="separator:a35c353846b88cb39d4c8d12ba4f5ca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f59d33d16332dd8dd96d800c33d06e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a21f59d33d16332dd8dd96d800c33d06e">SetUserUpdateThread</a> (void(*_userUpdateThreadPtr)(<a class="el" href="classRakNet_1_1RakPeerInterface.html">RakPeerInterface</a> *, void *), void *_userUpdateThreadData)</td></tr>
<tr class="separator:a21f59d33d16332dd8dd96d800c33d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a1dc3d239d3c5114bc781144d3b73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a959a1dc3d239d3c5114bc781144d3b73">SetIncomingDatagramEventHandler</a> (bool(*_incomingDatagramEventHandler)(RNS2RecvStruct *))</td></tr>
<tr class="separator:a959a1dc3d239d3c5114bc781144d3b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a4348d90eb454b4d470d45fb19b99e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a38a4348d90eb454b4d470d45fb19b99e">ApplyNetworkSimulator</a> (float packetloss, unsigned short minExtraPing, unsigned short extraPingVariance)</td></tr>
<tr class="separator:a38a4348d90eb454b4d470d45fb19b99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c67c61c6eebed7a4ed8bc2ea2813b56"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a9c67c61c6eebed7a4ed8bc2ea2813b56">SetPerConnectionOutgoingBandwidthLimit</a> (unsigned maxBitsPerSecond)</td></tr>
<tr class="separator:a9c67c61c6eebed7a4ed8bc2ea2813b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9c2b58a0970b6a80e50b1ecf470e43"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#adc9c2b58a0970b6a80e50b1ecf470e43">IsNetworkSimulatorActive</a> (void)</td></tr>
<tr class="separator:adc9c2b58a0970b6a80e50b1ecf470e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d31a8a91862a6c796730dc3a35f98ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a0d31a8a91862a6c796730dc3a35f98ee">GetStatistics</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress, <a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *rns=0)</td></tr>
<tr class="memdesc:a0d31a8a91862a6c796730dc3a35f98ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a structure containing a large set of network statistics for the specified system. You can map this data to a string using the C style <a class="el" href="namespaceRakNet.html#a49d0ff9db0d324a890e9c08add72a131">StatisticsToString()</a> function.  <a href="#a0d31a8a91862a6c796730dc3a35f98ee"></a><br/></td></tr>
<tr class="separator:a0d31a8a91862a6c796730dc3a35f98ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399f918602df7cb051b038e17ad67ecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a399f918602df7cb051b038e17ad67ecf">GetStatistics</a> (const unsigned int index, <a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *rns)</td></tr>
<tr class="memdesc:a399f918602df7cb051b038e17ad67ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the network statistics of the system at the given index in the remoteSystemList.  <a href="#a399f918602df7cb051b038e17ad67ecf"></a><br/></td></tr>
<tr class="separator:a399f918602df7cb051b038e17ad67ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffede0c021450b37b16e6946c694a7d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#acffede0c021450b37b16e6946c694a7d">GetStatisticsList</a> (<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &gt; &amp;addresses, <a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &gt; &amp;guids, <a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> &gt; &amp;statistics)</td></tr>
<tr class="memdesc:acffede0c021450b37b16e6946c694a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of systems, and statistics for each of those systems Each system has one entry in each of the lists, in the same order.  <a href="#acffede0c021450b37b16e6946c694a7d"></a><br/></td></tr>
<tr class="separator:acffede0c021450b37b16e6946c694a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf51ef909abde91448a0a5d17e1da65c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf51ef909abde91448a0a5d17e1da65c"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#adf51ef909abde91448a0a5d17e1da65c">GetReceiveBufferSize</a> (void)</td></tr>
<tr class="memdesc:adf51ef909abde91448a0a5d17e1da65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">how many messages are waiting when you call <a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740" title="Gets a message from the incoming message queue.">Receive()</a> <br/></td></tr>
<tr class="separator:adf51ef909abde91448a0a5d17e1da65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRakNet_1_1RakPeerInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRakNet_1_1RakPeerInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRakNet_1_1RakPeerInterface.html">RakNet::RakPeerInterface</a></td></tr>
<tr class="memitem:a154354ae29d11ac06ef34bd64a8dd6aa inherit pub_methods_classRakNet_1_1RakPeerInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a154354ae29d11ac06ef34bd64a8dd6aa"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#a154354ae29d11ac06ef34bd64a8dd6aa">~RakPeerInterface</a> ()</td></tr>
<tr class="memdesc:a154354ae29d11ac06ef34bd64a8dd6aa inherit pub_methods_classRakNet_1_1RakPeerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a154354ae29d11ac06ef34bd64a8dd6aa inherit pub_methods_classRakNet_1_1RakPeerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a380285f3ca2ce6bc081fc8fcb4541cc9"><td class="memItemLeft" align="right" valign="top">RemoteSystemStruct *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a380285f3ca2ce6bc081fc8fcb4541cc9">GetRemoteSystemFromSystemAddress</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress, bool calledFromNetworkThread, bool onlyActive) const </td></tr>
<tr class="separator:a380285f3ca2ce6bc081fc8fcb4541cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae483d3f2306ada5fc2d79bde1663130d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae483d3f2306ada5fc2d79bde1663130d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ae483d3f2306ada5fc2d79bde1663130d">ParseConnectionRequestPacket</a> (RakPeer::RemoteSystemStruct *remoteSystem, const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;systemAddress, const char *data, int byteSize)</td></tr>
<tr class="memdesc:ae483d3f2306ada5fc2d79bde1663130d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse out a connection request packet. <br/></td></tr>
<tr class="separator:ae483d3f2306ada5fc2d79bde1663130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff708e05373259e91ec0a863fbaf375"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abff708e05373259e91ec0a863fbaf375"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#abff708e05373259e91ec0a863fbaf375">NotifyAndFlagForShutdown</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress, bool performImmediate, unsigned char orderingChannel, <a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority)</td></tr>
<tr class="memdesc:abff708e05373259e91ec0a863fbaf375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a reliable disconnect packet to this player and disconnect them when it is delivered. <br/></td></tr>
<tr class="separator:abff708e05373259e91ec0a863fbaf375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea8348eddf6e6b24f6e438b3c5f881d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acea8348eddf6e6b24f6e438b3c5f881d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#acea8348eddf6e6b24f6e438b3c5f881d">GetNumberOfRemoteInitiatedConnections</a> (void) const </td></tr>
<tr class="memdesc:acea8348eddf6e6b24f6e438b3c5f881d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many remote systems initiated a connection to us. <br/></td></tr>
<tr class="separator:acea8348eddf6e6b24f6e438b3c5f881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da01b7948820f3527590e3fc09869da"><td class="memItemLeft" align="right" valign="top">RemoteSystemStruct *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a2da01b7948820f3527590e3fc09869da">AssignSystemAddressToRemoteSystemList</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress, RemoteSystemStruct::ConnectMode connectionMode, RakNetSocket2 *incomingRakNetSocket, bool *thisIPConnectedRecently, <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> bindingAddress, int incomingMTU, <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> guid, bool useSecurity)</td></tr>
<tr class="memdesc:a2da01b7948820f3527590e3fc09869da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a free remote system from the list and assign our systemAddress to it.  <a href="#a2da01b7948820f3527590e3fc09869da"></a><br/></td></tr>
<tr class="separator:a2da01b7948820f3527590e3fc09869da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9251492e6d3d0538111c1d90be554b2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a9251492e6d3d0538111c1d90be554b2d">ShiftIncomingTimestamp</a> (unsigned char *data, const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;systemAddress) const </td></tr>
<tr class="memdesc:a9251492e6d3d0538111c1d90be554b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the timestamp of the incoming packet to be relative to this system.  <a href="#a9251492e6d3d0538111c1d90be554b2d"></a><br/></td></tr>
<tr class="separator:a9251492e6d3d0538111c1d90be554b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e23c8101ff1db0f6d6429afb7b1e711"><td class="memItemLeft" align="right" valign="top">RakNet::Time&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a1e23c8101ff1db0f6d6429afb7b1e711">GetBestClockDifferential</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress) const </td></tr>
<tr class="separator:a1e23c8101ff1db0f6d6429afb7b1e711"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af64c716502f8489c8b674cde838e9d97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af64c716502f8489c8b674cde838e9d97"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#af64c716502f8489c8b674cde838e9d97">endThreads</a></td></tr>
<tr class="memdesc:af64c716502f8489c8b674cde838e9d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to true to terminate the Peer thread execution. <br/></td></tr>
<tr class="separator:af64c716502f8489c8b674cde838e9d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f5e5755c03755c06eb7f1276f90f19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f5e5755c03755c06eb7f1276f90f19"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#af2f5e5755c03755c06eb7f1276f90f19">isMainLoopThreadActive</a></td></tr>
<tr class="memdesc:af2f5e5755c03755c06eb7f1276f90f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the peer thread is active. <br/></td></tr>
<tr class="separator:af2f5e5755c03755c06eb7f1276f90f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faf5bd4ea7dca603f967b6ee1ed40d9"><td class="memItemLeft" align="right" valign="top">*unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a9faf5bd4ea7dca603f967b6ee1ed40d9">maximumNumberOfPeers</a></td></tr>
<tr class="memdesc:a9faf5bd4ea7dca603f967b6ee1ed40d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the maximum number of peers allowed to connect.  <a href="#a9faf5bd4ea7dca603f967b6ee1ed40d9"></a><br/></td></tr>
<tr class="separator:a9faf5bd4ea7dca603f967b6ee1ed40d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6244b23254ae6e95302b5060b3f1bc0e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a6244b23254ae6e95302b5060b3f1bc0e">maximumIncomingConnections</a></td></tr>
<tr class="memdesc:a6244b23254ae6e95302b5060b3f1bc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the maximum number of peers able to connect, including reserved connection slots for pings, etc.  <a href="#a6244b23254ae6e95302b5060b3f1bc0e"></a><br/></td></tr>
<tr class="separator:a6244b23254ae6e95302b5060b3f1bc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fac920e5b3388a3e1eb9ef5ebea60f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79fac920e5b3388a3e1eb9ef5ebea60f"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a79fac920e5b3388a3e1eb9ef5ebea60f">incomingPassword</a> [256]</td></tr>
<tr class="memdesc:a79fac920e5b3388a3e1eb9ef5ebea60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Player ID. <br/></td></tr>
<tr class="separator:a79fac920e5b3388a3e1eb9ef5ebea60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a287f35dd77985ae4ac579e6adf76"><td class="memItemLeft" align="right" valign="top">RemoteSystemStruct *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a433a287f35dd77985ae4ac579e6adf76">remoteSystemList</a></td></tr>
<tr class="separator:a433a287f35dd77985ae4ac579e6adf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cab96454717bfcbc2cfda6f88d8cc0"><td class="memItemLeft" align="right" valign="top">RemoteSystemStruct **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#ad8cab96454717bfcbc2cfda6f88d8cc0">activeSystemList</a></td></tr>
<tr class="separator:ad8cab96454717bfcbc2cfda6f88d8cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ed36c02a71245b4159ddee3be909a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ed36c02a71245b4159ddee3be909a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#af4ed36c02a71245b4159ddee3be909a1">updateCycleIsRunning</a></td></tr>
<tr class="memdesc:af4ed36c02a71245b4159ddee3be909a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">RunUpdateCycle is not thread safe but we don't need to mutex calls. Just skip calls if it is running already. <br/></td></tr>
<tr class="separator:af4ed36c02a71245b4159ddee3be909a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ec9044cab71ff6f0ecc3b60e21b76"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a031ec9044cab71ff6f0ecc3b60e21b76">bytesSentPerSecond</a></td></tr>
<tr class="memdesc:a031ec9044cab71ff6f0ecc3b60e21b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of people we have tried to connect to recently.  <a href="#a031ec9044cab71ff6f0ecc3b60e21b76"></a><br/></td></tr>
<tr class="separator:a031ec9044cab71ff6f0ecc3b60e21b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d820f9f09600401b3689a599242832a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#a9d820f9f09600401b3689a599242832a">allowConnectionResponseIPMigration</a></td></tr>
<tr class="memdesc:a9d820f9f09600401b3689a599242832a"><td class="mdescLeft">&#160;</td><td class="mdescRight">How long it has been since things were updated by a call to receiveUpdate thread uses this to determine how long to sleep for.  <a href="#a9d820f9f09600401b3689a599242832a"></a><br/></td></tr>
<tr class="separator:a9d820f9f09600401b3689a599242832a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4972e4a0c0573671148f33ca2c9ebd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRakNet_1_1SimpleMutex.html">SimpleMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeer.html#aa4972e4a0c0573671148f33ca2c9ebd6">sendReceiptSerialMutex</a></td></tr>
<tr class="separator:aa4972e4a0c0573671148f33ca2c9ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classRakNet_1_1RakPeerInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classRakNet_1_1RakPeerInterface')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classRakNet_1_1RakPeerInterface.html">RakNet::RakPeerInterface</a></td></tr>
<tr class="memitem:a8e05f80c6e0de8f1b6e644700b7ce543 inherit pub_static_methods_classRakNet_1_1RakPeerInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e05f80c6e0de8f1b6e644700b7ce543"></a>
static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#a8e05f80c6e0de8f1b6e644700b7ce543">Get64BitUniqueRandomNumber</a> (void)</td></tr>
<tr class="memdesc:a8e05f80c6e0de8f1b6e644700b7ce543 inherit pub_static_methods_classRakNet_1_1RakPeerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random number (to generate a GUID) <br/></td></tr>
<tr class="separator:a8e05f80c6e0de8f1b6e644700b7ce543 inherit pub_static_methods_classRakNet_1_1RakPeerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main interface for network communications. </p>
<p>It implements most of <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher that can be used f...">RakNet</a>'s functionality and is the primary interface for <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher that can be used f...">RakNet</a>.</p>
<p>Inherits <a class="el" href="classRakNet_1_1RakPeerInterface.html" title="The main interface for network communications.">RakPeerInterface</a>.</p>
<p>See the individual functions for what the class can do. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad403c131efe8bfe6f3c5280e110b9b2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::AddToBanList </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>IP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNet::TimeMS&#160;</td>
          <td class="paramname"><em>milliseconds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bans an IP from connecting. </p>
<p>Banned IPs persist between connections but are not saved on shutdown nor loaded on startup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IP</td><td>Dotted IP address. You can use * for a wildcard address, such as 128.0.0. * will ban all IP addresses starting with 128.0.0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>Gives time in milli seconds for a temporary ban of the IP address. Use 0 for a permanent ban. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ab44199db81cf4fa834d42efc5eb5ae77">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ab927e4b0e70fcc0e06d1ba6a70315eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::AddToSecurityExceptionList </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is useful if you have a fixed-address internal server behind a LAN. </p>
<p>Secure connections are determined by the recipient of an incoming connection. This has no effect if called on the system attempting to connect. </p>
<dl class="section note"><dt>Note</dt><dd>If secure connections are on, do not use secure connections for a specific IP address. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ip</td><td>IP address to add. * wildcards are supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a5ba3e8713e5d7b150ed393eced79675d">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aecb0396cdb296a5df8b8266c8cce138d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::AdvertiseSystem </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>connectionSocketIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system. This will send our external IP outside the LAN along with some user data to the remote system. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The sender and recipient must already be started via a successful call to Initialize </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remotePort</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Optional data to append to the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>Length of data in bytes. Use 0 if no data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionSocketIndex</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to send on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <a class="el" href="classRakNet_1_1RakPeer.html#ae6bb2c4de0b24283b231154d29304e00" title="Returns true if the network thread is running.">IsActive()</a>==false or the host is unresolvable. True otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#adccf6f091e1ac19ad92099d50fe649d7">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a5be8b42a06fdd32f29f032ba5fc5e7b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1Packet.html">Packet</a>* RakNet::RakPeer::AllocatePacket </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dataSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a packet for you to write to if you want to create a <a class="el" href="structRakNet_1_1Packet.html" title="This represents a user message from another system.">Packet</a> for some reason. You can add it to the receive buffer with PushBackPacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>How many bytes to allocate for the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A packet. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a3e38bdd227138f640a942102813ce779">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a3b24a4946b34071621b0b288b869f21f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::AllowConnectionResponseIPMigration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow or disallow connection responses from any IP. </p>
<p>Normally this should be false, but may be necessary when connecting to servers with multiple IP addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allow</td><td>- True to allow this behavior, false to not allow. Defaults to false. Value persists between connections. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#aa4a2525f004aaf073e1b25b0ffe0c0d2">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a38a4348d90eb454b4d470d45fb19b99e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeer::ApplyNetworkSimulator </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>packetloss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>minExtraPing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>extraPingVariance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds simulated ping and packet loss to the outgoing data flow. To simulate bi-directional ping and packet loss, you should call this on both the sender and the recipient, with half the total ping and packetloss value on each. You can exclude network simulator code with the _RELEASE #define to decrease code size </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a href="http://www.jenkinssoftware.com/forum/index.php?topic=1671.0">http://www.jenkinssoftware.com/forum/index.php?topic=1671.0</a> instead. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't work past version 3.6201 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetloss</td><td>Chance to lose a packet. Ranges from 0 to 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minExtraPing</td><td>The minimum time to delay sends. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extraPingVariance</td><td>The additional random time to delay sends. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a03910361629f5cbabe0df0612a1f2709">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a2da01b7948820f3527590e3fc09869da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RemoteSystemStruct* RakNet::RakPeer::AssignSystemAddressToRemoteSystemList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemoteSystemStruct::ConnectMode&#160;</td>
          <td class="paramname"><em>connectionMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetSocket2 *&#160;</td>
          <td class="paramname"><em>incomingRakNetSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>thisIPConnectedRecently</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>bindingAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incomingMTU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useSecurity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a free remote system from the list and assign our systemAddress to it. </p>
<dl class="section note"><dt>Note</dt><dd>Should only be called from the update thread - not the user thread. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>systemAddress to be assigned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionMode</td><td>connection mode of the RemoteSystem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rakNetSocket</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thisIPConnectedRecently</td><td>Is this IP connected recently? set to False; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bindingAddress</td><td>Address to be binded with the remote system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">incomingMTU</td><td>MTU for the remote system </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ceacd63ae51089a2e36287c54f07ffe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::AttachPlugin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *&#160;</td>
          <td class="paramname"><em>plugin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a Plugin interface to an instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) to run code automatically on message receipt in the Receive call. If the plugin returns false from PluginInterface::UsesReliabilityLayer(), which is the case for all plugins except <a class="el" href="classRakNet_1_1PacketLogger.html" title="Writes incoming and outgoing messages to the screen. This will write all incoming and outgoing messag...">PacketLogger</a>, you can call <a class="el" href="classRakNet_1_1RakPeer.html#a4ceacd63ae51089a2e36287c54f07ffe" title="Attaches a Plugin interface to an instance of the base class (RakPeer or PacketizedTCP) to run code a...">AttachPlugin()</a> and <a class="el" href="classRakNet_1_1RakPeer.html#a9f29151642a0ad0abdddc6d9a8f25239" title="Detaches a Plugin interface from the instance of the base class (RakPeer or PacketizedTCP) it is atta...">DetachPlugin()</a> for this plugin while <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageHandler</td><td>Pointer to the plugin to attach. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a2cfd224842b6f1d5e2881901c9f71531">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a5f934680b37ffbfdc0047ac406fc2512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::CancelConnectionAttempt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel a pending connection attempt. </p>
<p>If we are already connected, the connection stays open </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Target system to cancel. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ad70d63c4093c1351f4a0c2949eac312a">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a95e3806fce8552e322236abcf105cbf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::CloseConnection </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendDisconnectionNotification</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>orderingChannel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a>&#160;</td>
          <td class="paramname"><em>disconnectionNotificationPriority</em> = <code><a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705cadb8ee22a232a2787f32ba28da55c43c1">LOW_PRIORITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out). </p>
<p>This method closes the connection irrespective of who initiated the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Which system to close the connection to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendDisconnectionNotification</td><td>True to send ID_DISCONNECTION_NOTIFICATION to the recipient. False to close it silently. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>Which ordering channel to send the disconnection notification on, if any </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disconnectionNotificationPriority</td><td>Priority to send ID_DISCONNECTION_NOTIFICATION on. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#afd637c6f44cb84ce5c151c700bb5cafe">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a19979ff2acc15abe22785fc55c1c656c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConnectionAttemptResult RakNet::RakPeer::Connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>passwordDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *&#160;</td>
          <td class="paramname"><em>publicKey</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>connectionSocketIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sendConnectionAttemptCount</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeBetweenSendConnectionAttemptsMS</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNet::TimeMS&#160;</td>
          <td class="paramname"><em>timeoutTime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect to the specified host (ip or domain name) and server port. </p>
<p>Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client. Calling both acts as a true peer.</p>
<p>This is a non-blocking connection.</p>
<p>The connection is successful when <a class="el" href="classRakNet_1_1RakPeer.html#a514c8d6f1dc75b5e9bb3cb5b9dcb632b">GetConnectionState()</a> returns IS_CONNECTED or <a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740" title="Gets a message from the incoming message queue.">Receive()</a> gets a message with the type identifier ID_CONNECTION_REQUEST_ACCEPTED. If the connection is not successful, such as a rejected connection or no response then neither of these things will happen. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Requires that you first call <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">Startup()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Either a dotted IP address or a domain name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remotePort</td><td>Port to connect to on the remote machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passwordData</td><td>A data block that must match the data block on the server passed to <a class="el" href="classRakNet_1_1RakPeer.html#a6d4071bbbf128604c94a27c46fa7b9ce" title="Sets the password for the incoming connections.">SetIncomingPassword()</a>. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passwordDataLength</td><td>The length in bytes of passwordData. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">publicKey</td><td>The public key the server is using. If 0, the server is not using security. If non-zero, the publicKeyMode member determines how to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionSocketIndex</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to determine the one to send on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendConnectionAttemptCount</td><td>Number of datagrams to send to the other system to try to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeBetweenSendConnectionAttemptsMS</td><td>Time to elapse before a datagram is sent to the other system to try to connect. After sendConnectionAttemptCount number of attempts, ID_CONNECTION_ATTEMPT_FAILED is returned. Under low bandwidth conditions with multiple simultaneous outgoing connections, this value should be raised to 1000 or higher, or else the MTU detection can overrun the available bandwidth. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutTime</td><td>Time to elapse before dropping the connection if a reliable message could not be sent. 0 to use the default value from SetTimeoutTime(UNASSIGNED_SYSTEM_ADDRESS); </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CONNECTION_ATTEMPT_STARTED on successful initiation. Otherwise, an appropriate enumeration indicating failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>CONNECTION_ATTEMPT_STARTED does not mean you are already connected! </dd>
<dd>
It is possible to immediately get back ID_CONNECTION_ATTEMPT_FAILED if you exceed the maxConnections parameter passed to <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">Startup()</a>. This could happen if you call <a class="el" href="classRakNet_1_1RakPeer.html#a95e3806fce8552e322236abcf105cbf9" title="Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out).">CloseConnection()</a> with sendDisconnectionNotificaiton true, then immediately call <a class="el" href="classRakNet_1_1RakPeer.html#a19979ff2acc15abe22785fc55c1c656c" title="Connect to the specified host (ip or domain name) and server port.">Connect()</a> before the connection has closed. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a451dd5d225277fe5806d3d700551fb76">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a8852b99f2d8919bee57fd457477292a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ConnectionAttemptResult RakNet::RakPeer::ConnectWithSocket </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>passwordDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetSocket2 *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *&#160;</td>
          <td class="paramname"><em>publicKey</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sendConnectionAttemptCount</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeBetweenSendConnectionAttemptsMS</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNet::TimeMS&#160;</td>
          <td class="paramname"><em>timeoutTime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect to the specified host (ip or domain name) and server port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Either a dotted IP address or a domain name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remotePort</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passwordData</td><td>A data block that must match the data block on the server passed to <a class="el" href="classRakNet_1_1RakPeer.html#a6d4071bbbf128604c94a27c46fa7b9ce" title="Sets the password for the incoming connections.">SetIncomingPassword()</a>. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passwordDataLength</td><td>The length in bytes of passwordData. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>A bound socket returned by another instance of <a class="el" href="classRakNet_1_1RakPeerInterface.html" title="The main interface for network communications.">RakPeerInterface</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendConnectionAttemptCount</td><td>Number of datagrams to send to the other system to try to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeBetweenSendConnectionAttemptsMS</td><td>Time to elapse before a datagram is sent to the other system to try to connect. After sendConnectionAttemptCount number of attempts, ID_CONNECTION_ATTEMPT_FAILED is returned.. Under low bandwidth conditions with multiple simultaneous outgoing connections, this value should be raised to 1000 or higher, or else the MTU detection can overrun the available bandwidth. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutTime</td><td>Time to elapse before dropping the connection if a reliable message could not be sent. 0 to use the default from SetTimeoutTime(UNASSIGNED_SYSTEM_ADDRESS); </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CONNECTION_ATTEMPT_STARTED on successful initiation. Otherwise, an appropriate enumeration indicating failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>CONNECTION_ATTEMPT_STARTED does not mean you are already connected! </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a818333f4aa6365dc1db5b1e3c4c31f64">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ae3e053f8f77d9b2e7b7fcd03f8f9120e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::DeallocatePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this to deallocate a message returned by <a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740" title="Gets a message from the incoming message queue.">Receive()</a> when you are done handling it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>Message to deallocate. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a21b929aba61ce69aab32871db33d6ede">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a9f29151642a0ad0abdddc6d9a8f25239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::DetachPlugin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *&#160;</td>
          <td class="paramname"><em>messageHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches a Plugin interface from the instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) it is attached to. </p>
<p>This method disables the plugin code from running automatically on base class's updates or message receipt. If the plugin returns false from PluginInterface::UsesReliabilityLayer(), which is the case for all plugins except <a class="el" href="classRakNet_1_1PacketLogger.html" title="Writes incoming and outgoing messages to the screen. This will write all incoming and outgoing messag...">PacketLogger</a>, you can call <a class="el" href="classRakNet_1_1RakPeer.html#a4ceacd63ae51089a2e36287c54f07ffe" title="Attaches a Plugin interface to an instance of the base class (RakPeer or PacketizedTCP) to run code a...">AttachPlugin()</a> and <a class="el" href="classRakNet_1_1RakPeer.html#a9f29151642a0ad0abdddc6d9a8f25239" title="Detaches a Plugin interface from the instance of the base class (RakPeer or PacketizedTCP) it is atta...">DetachPlugin()</a> for this plugin while <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageHandler</td><td>Pointer to a plugin to detach. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a4960f6a8d37d70e7e98f1f6fe54e323d">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a489dd712e953836042df5711c8eb7e76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::DisableSecurity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disables security for incoming connections. </p>
<dl class="section note"><dt>Note</dt><dd>Must be called while offline </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#aab566dbe8f666dfed108aaaabc7a0ca6">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a2b735d6075d64dcdf5c554989f4a5f98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RakNet::RakPeer::GetAveragePing </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the average of all ping times read for the specific system or -1 if none read yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>Which system we are referring to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ping time for this system, or -1 </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a15627acab7077970975889d4e83dc59b">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a1e23c8101ff1db0f6d6429afb7b1e711"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RakNet::Time RakNet::RakPeer::GetBestClockDifferential </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>systemAddress</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the most accurate clock differential for a certain player. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>The player with whose clock the time difference is calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The clock differential for a certain player. </dd></dl>

</div>
</div>
<a class="anchor" id="abc607f77d9724097030d2da6868074b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::GetClientPublicKeyFromSystemAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>client_public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> of a connected system, get the public key they provided as an identity Returns false if system address was not found or client public key is not known </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> of the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client_public_key</td><td>The connected client's public key is copied to this address. Buffer must be cat::EasyHandshake::PUBLIC_KEY_BYTES bytes in length. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a7139f333758a31e5a1f44f06b120f085">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ac1f87a029e47963ae24838ec87c1a076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RakNet::Time RakNet::RakPeer::GetClockDifferential </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the clock difference between your system and the specified system Subtract <a class="el" href="classRakNet_1_1RakPeer.html#ac1f87a029e47963ae24838ec87c1a076">GetClockDifferential()</a> from a time returned by the remote system to get that time relative to your own system Returns 0 if the system is unknown </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemIdentifier</td><td>Which system we are referring to </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a7fa284803461a09efeffd65d73068c51">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a0af5b69face182410f2abb11da902dd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::GetConnectionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> *&#160;</td>
          <td class="paramname"><em>remoteSystems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>numberOfSystems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the array remoteSystems with the <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> of all the systems we are connected to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">remoteSystems</td><td>An array of <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structures, to be filled with the SystemAddresss of the systems we are connected to. Pass 0 to remoteSystems to get the number of systems we are connected to. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">numberOfSystems</td><td>As input, the size of remoteSystems array. As output, the number of elements put into the array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a5706fd26cf90bd45d0658d8b9a7d8111">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a514c8d6f1dc75b5e9bb3cb5b9dcb632b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRakNet.html#a84a0fb005391f71130dd341f77f62138">ConnectionState</a> RakNet::RakPeer::GetConnectionState </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns if a system is connected, disconnected, connecting in progress, or various other states </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemIdentifier</td><td>The system we are referring to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This locks a mutex, do not call too frequently during connection attempts or the attempt will take longer and possibly even timeout </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>What state the remote system is in </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a33744f90a202b8e57d6a825d6af080cc">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a96f0e923c413fe2319d17862605d6622"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeer::GetExternalID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique address identifier that represents the target on the the network and is based on the target's external IP / port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> of the remote system. Usually the same for all systems, unless you have two or more network cards. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a94602ad7356b4a99f862f9793327c325">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ab639b98f7b007833b08930de45545433"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> RakNet::RakPeer::GetGUIDFromIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as GetSystemAddressFromIndex but returns <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index should range between 0 and the maximum number of players allowed - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ac86fcbe5e750b08378703197bd9fddcf">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a41fcd1175cb8fee67b12835944ed51da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&amp; RakNet::RakPeer::GetGuidFromSystemAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a connected system address, this method gives the unique GUID representing that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>. This will be the same on all systems connected to that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Complexity is O(log2(n)). If <em>input</em> is UNASSIGNED_SYSTEM_ADDRESS, will return your own GUID. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Call <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">Startup()</a> first, or the function will return UNASSIGNED_RAKNET_GUID </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The system address of the target system we are connected to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#aac8203dda2ba1271e753bd113b259173">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a395e269dce0de14f22bfb870923f22b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::GetIncomingPassword </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>passwordDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the password passed to SetIncomingPassword. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">passwordData</td><td>Should point to a block large enough to hold the password data you passed to <a class="el" href="classRakNet_1_1RakPeer.html#a6d4071bbbf128604c94a27c46fa7b9ce" title="Sets the password for the incoming connections.">SetIncomingPassword()</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">passwordDataLength</td><td>Maximum size of the passwordData array. Modified to hold the number of bytes actually written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a8b5026f40cf8e6f307e2d3ac82970a30">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ad77373ffe92c37f01b39bc16c62ac9ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RakNet::RakPeer::GetIndexFromSystemAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>systemAddress</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <em>systemAddress</em>, returns its index into remoteSystemList. </p>
<p>Values range from 0 to the maximum number of players allowed - 1. This includes systems which were formerly connected, but are now not connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>The <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> we are referring to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of this <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> or -1 on system not found. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ab2015109d6bf787c46880fde513d4276">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="acf82a248aa543c9ec04567c14004fea5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeer::GetInternalID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>systemAddress</em> = <code><a class="el" href="namespaceRakNet.html#a80c95b4ed53f42911a6fa92b85e929cf">UNASSIGNED_SYSTEM_ADDRESS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique address identifier that represents you or another system on the the network. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported by the XBOX </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>Use UNASSIGNED_SYSTEM_ADDRESS to get your behind-LAN address. Use a connected system to get their behind-LAN address. This does not return the port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>When you have multiple internal IDs, which index to return? Currently limited to MAXIMUM_NUMBER_OF_INTERNAL_IDS (so the maximum value of this variable is MAXIMUM_NUMBER_OF_INTERNAL_IDS-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of your system internally, which may not be how other systems see if you if you are behind a NAT or proxy. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a928a49c193687ccef547f7ea3634bb54">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a7a21e884778d65fb4493b29e5c1826c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RakNet::RakPeer::GetLastPing </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last ping time read for the specific system or -1 if none read yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>Which system we are referring to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last ping time for this system, or -1. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a0fb0115e5c85094d48239f157d9eccbb">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aa78c5de86816a54cae137bffb7e49bc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* RakNet::RakPeer::GetLocalIP </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an IP address at index 0 to GetNumberOfAddresses-1 in ipList array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index into the list of IP addresses </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local IP address at this index </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ad070246537065910a500803bdf6b9cb2">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="afdb8673a54a5f3926ac93e13a4a20367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RakNet::RakPeer::GetLowestPing </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest ping time read or -1 if none read yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemIdentifier</td><td>Which system we are referring to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest ping time for this system, or -1. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a4eb8b0f288db5425906cd72ee5f8fae9">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a21eac8d486bbcb12e350c49c43c92618"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RakNet::RakPeer::GetMaximumIncomingConnections </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value passed to <a class="el" href="classRakNet_1_1RakPeer.html#a8ed81856dd81ec1cd00e17fafedee0a7" title="Sets the maximum number of incoming connections allowed.">SetMaximumIncomingConnections()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of incoming connections, which is always &lt;= maxConnections </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#aa2985b696b46b347f5825e11e7219f83">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="abd1743ff40a69e0362cdb483d88b801b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RakNet::RakPeer::GetMaximumNumberOfPeers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of connections we are allowed. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of connections allowed. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#abfe4c34f55a92b7c0fd90ff9bbb3f644">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="af5948dcad656f51305ed20c8b38e529b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RakNet::RakPeer::GetMTUSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current MTU size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Which system to get MTU for. UNASSIGNED_SYSTEM_ADDRESS to get the default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current MTU size of the target system. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#af7359755639152292a3e35b6fb9877bb">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a1d6e283f476bdd4ed8b9b4c56693ecd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakNet::RakPeer::GetNextSendReceipt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next uint32_t that <a class="el" href="classRakNet_1_1RakPeer.html#a1ee7422f744ab606c92b4ed4b28db40e" title="Sends a block of data to the specified system that you are connected to.">Send()</a> will return </p>
<dl class="section note"><dt>Note</dt><dd>If using <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> from multiple threads, this may not be accurate for your thread. Use <a class="el" href="classRakNet_1_1RakPeer.html#a9232bd1bc9c1a223ecef8682133f95ac">IncrementNextSendReceipt()</a> in that case. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The next uint32_t that <a class="el" href="classRakNet_1_1RakPeer.html#a1ee7422f744ab606c92b4ed4b28db40e" title="Sends a block of data to the specified system that you are connected to.">Send()</a> or SendList will return </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a8587fe2920712adddfa06950ff6b8998">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aca51c8583f3995217a940bf592d7140c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned RakNet::RakPeer::GetNumberOfAddresses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of IP addresses this system has internally. </p>
<p>Get the actual addresses from <a class="el" href="classRakNet_1_1RakPeer.html#aa78c5de86816a54cae137bffb7e49bc5">GetLocalIP()</a> </p>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a59b3cee62120132170dcf065b84114b2">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aec33659d51a00eed12bd1dc8a24071b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::GetOfflinePingResponse </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointers to a copy of the <em>data</em> passed to SetOfflinePingResponse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>A pointer to a copy of the data passed to <a class="el" href="classRakNet_1_1RakPeer.html#a2a534f1c0bb56b3c5b9b56ca8839917c" title="Sets the data to send along with a LAN server discovery or offline ping reply.">SetOfflinePingResponse()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>A pointer filled in with the length parameter passed to <a class="el" href="classRakNet_1_1RakPeer.html#a2a534f1c0bb56b3c5b9b56ca8839917c" title="Sets the data to send along with a LAN server discovery or offline ping reply.">SetOfflinePingResponse()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRakNet_1_1RakPeer.html#a2a534f1c0bb56b3c5b9b56ca8839917c" title="Sets the data to send along with a LAN server discovery or offline ping reply.">SetOfflinePingResponse</a> </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ae61f8651e8a45acec5bdf04384777a86">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a380285f3ca2ce6bc081fc8fcb4541cc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RemoteSystemStruct* RakNet::RakPeer::GetRemoteSystemFromSystemAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calledFromNetworkThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the reliability layer associated with a systemAddress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>The player identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if none </dd></dl>

</div>
</div>
<a class="anchor" id="ab69ef5d63339d36dc99b905586a23151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual RakNetSocket2* RakNet::RakPeer::GetSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the socket used with a particular active connection. The smart pointer reference counts the RakNetSocket object, so the socket will remain active as long as the smart pointer does, even if <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher that can be used f...">RakNet</a> were to shutdown or close the connection. </p>
<dl class="section note"><dt>Note</dt><dd>This sends a query to the thread and blocks on the return value for up to one second. In practice it should only take a millisecond or so. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Which system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer object containing the socket information about the target. Be sure to check IsNull() which is returned if the update thread is unresponsive, shutting down, or if this system is not connected. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#adae8cd6baaa718eb5a818f5271a58122">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a35c353846b88cb39d4c8d12ba4f5ca42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeer::GetSockets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; RakNetSocket2 * &gt; &amp;&#160;</td>
          <td class="paramname"><em>sockets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all sockets in use. </p>
<dl class="section note"><dt>Note</dt><dd>This sends a query to the thread and blocks on the return value for up to one second. In practice it should only take a millisecond or so. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sockets</td><td>List of RakNetSocket structures in use. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a09ef1181af600ec2c255a295154fe367">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="af9f01256eab673794028fe48980ef6fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RakNet::RakPeer::GetSplitMessageProgressInterval </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns what was passed to <a class="el" href="classRakNet_1_1RakPeer.html#a35e89d9813d6f6e7f2144a6a0437a33b" title="Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads.">SetSplitMessageProgressInterval()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of messages to be recieved before a download progress notification is returned. Default to 0. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#abd4be92bcad53af859e502127c060247">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a0d31a8a91862a6c796730dc3a35f98ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a>* RakNet::RakPeer::GetStatistics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *&#160;</td>
          <td class="paramname"><em>rns</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a structure containing a large set of network statistics for the specified system. You can map this data to a string using the C style <a class="el" href="namespaceRakNet.html#a49d0ff9db0d324a890e9c08add72a131">StatisticsToString()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>Which connected system to get statistics for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rns</td><td>If you supply this structure,the network statistics will be written to it. Otherwise the method uses a static struct to write the data, which is not threadsafe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the specified system can't be found. Otherwise a pointer to the struct containing the specified system's network statistics. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="RakNetStatistics_8h.html" title="A structure that holds all statistical data returned by RakNet.">RakNetStatistics.h</a> </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a87e528130f7f0f21597a338769fe7139">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a399f918602df7cb051b038e17ad67ecf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::GetStatistics </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *&#160;</td>
          <td class="paramname"><em>rns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the network statistics of the system at the given index in the remoteSystemList. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the index is less than the maximum number of peers allowed and the system is active. False otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a28c5bd84842962e60097512a9f6ff463">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="acffede0c021450b37b16e6946c694a7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeer::GetStatisticsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>guids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>statistics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of systems, and statistics for each of those systems Each system has one entry in each of the lists, in the same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">addresses</td><td><a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> for each connected system </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">guids</td><td><a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> for each connected system </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">statistics</td><td>Calculated <a class="el" href="structRakNet_1_1RakNetStatistics.html" title="Network Statisics Usage.">RakNetStatistics</a> for each connected system </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ad474ee839667fb5e1b667ea5465dc021">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ac591b0ac4b88b9cdf182fc4769d9de98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeer::GetSystemAddressFromGuid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the system address of a connected system, given its GUID. The GUID will be the same on all systems connected to that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Currently O(log(n)), but this may be improved in the future If <em>input</em> is UNASSIGNED_RAKNET_GUID, UNASSIGNED_SYSTEM_ADDRESS is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> of the target system. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#adaaff66118400b6bbcb31c11419cd791">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aa3159d6eabc0a1a4298fb67c7fc7146b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeer::GetSystemAddressFromIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <em>index</em> into remoteSystemList, will return a <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a>. This function is only useful for looping through all systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index should range between 0 and the maximum number of players allowed - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structure corresponding to <em>index</em> in remoteSystemList. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#aaf66ca0e72313053922bfb1c1b602889">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a791779bb9714e830f19a5f12961576d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::GetSystemList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>guids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as calling GetSystemAddressFromIndex and GetGUIDFromIndex for all systems, but more efficient Indices match each other, so <em>addresses</em>[0] and <em>guids</em>[0] refer to the same system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">addresses</td><td>All system addresses. Size of the list is the number of connections. Size of the <em>addresses</em> list will match the size of the <em>guids</em> list. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">guids</td><td>All guids. Size of the list is the number of connections. Size of the list will match the size of the <em>addresses</em> list. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#aa1939c66f7190e3c647a6a685a6eb248">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a12dc51372f2a5a109f3c6a55ba799763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RakNet::TimeMS RakNet::RakPeer::GetTimeoutTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Timeout time for the given system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Target system to get the TimeoutTime for. Pass UNASSIGNED_SYSTEM_ADDRESS to get the default value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timeout time for a given system. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a0fd3a4d282327944ee50b00c79baf420">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a9232bd1bc9c1a223ecef8682133f95ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakNet::RakPeer::IncrementNextSendReceipt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next uint32_t that <a class="el" href="classRakNet_1_1RakPeer.html#a1ee7422f744ab606c92b4ed4b28db40e" title="Sends a block of data to the specified system that you are connected to.">Send()</a> will return, and increments the value by one </p>
<dl class="section note"><dt>Note</dt><dd>If using <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> from multiple threads, pass this to forceReceipt in the send function </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The next uint32_t that <a class="el" href="classRakNet_1_1RakPeer.html#a1ee7422f744ab606c92b4ed4b28db40e" title="Sends a block of data to the specified system that you are connected to.">Send()</a> or SendList will return </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a9a406f292a6c44f551e9d8606992558e">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a5445d0e8db3e7ef1e38b7fc5bc0d3920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::InitializeSecurity </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRequireClientKey</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you accept connections, you must call this or else security will not be enabled for incoming connections. This feature requires more round trips, bandwidth, and CPU time for the connection handshake x64 builds require under 25% of the CPU time of other builds See the Encryption sample for example usage </p>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called while offline </dd>
<dd>
LIBCAT_SECURITY must be defined to 1 in NativeFeatureIncludes.h for this function to have any effect </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publicKey</td><td>A pointer to the public key for accepting new connections </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">privateKey</td><td>A pointer to the private key for accepting new connections </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bRequireClientKey,:</td><td>Should be set to false for most servers. Allows the server to accept a public key from connecting clients as a proof of identity but eats twice as much CPU time as a normal connection </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ab5389821efb5d09470f8429925766eb3">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ae6bb2c4de0b24283b231154d29304e00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::IsActive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the network thread is running. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the network thread is running, False otherwise </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#affcba03406b89157976cf0e6a8924d66">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a499626110e1409b09e7d955722c4c3fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::IsBanned </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>IP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true or false indicating if a particular IP is banned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IP</td><td>Dotted IP address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if IP matches any IPs in the ban list, accounting for any wildcards. False otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ae28629f202de81ad4816470cd0f8fd94">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a654c29f6f195b0dcd105a856c99222d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::IsInSecurityExceptionList </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if a given IP is in the security exception list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IP</td><td>address to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the IP address is found in security exception list, else returns false. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a2672cee4147e50818769e3573fb5c459">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ad89d80f939408a620a5e41eeab0a588a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::IsLocalIP </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is this a local IP? Checks if this ip is in the ipList array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">An</td><td>IP address to check, excluding the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is one of the IP addresses returned by GetLocalIP </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ac37fe2c8b35abdc3a441541e539ebd10">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="adc9c2b58a0970b6a80e50b1ecf470e43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeer::IsNetworkSimulatorActive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns if you previously called ApplyNetworkSimulator </p>
<dl class="section return"><dt>Returns</dt><dd>If you previously called ApplyNetworkSimulator </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a917c367bcba491fb243161025b6eab01">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a4d47b849ba6e7ecf2d1fca3198a60ba5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short RakNet::RakPeer::NumberOfConnections </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many open connections exist at this time. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of open connections. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a88611e451f6f6e0d5f7cb00ce5bcabf9">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a9bb94828e0ad89e0d6c44a671bf22f8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::Ping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a ping to the specified connected system. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The sender and recipient must already be started via a successful call to <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">Startup()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Which system to ping </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a49dbff7ab8f516361e3d05645c2b7901">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="af7dd13a4c3d38e65bf816a604c6042c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::Ping </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyReplyOnAcceptingConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>connectionSocketIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a ping to the specified unconnected system. </p>
<p>The remote system, if it is Initialized, will respond with ID_PONG followed by sizeof(RakNet::TimeMS) containing the system time the ping was sent. Default is 4 bytes - See __GET_TIME_64BIT in <a class="el" href="RakNetTypes_8h.html" title="Types used by RakNet, most of which involve user code.">RakNetTypes.h</a> System should reply with ID_PONG if it is active </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Either a dotted IP address or a domain name. Can be 255.255.255.255 for LAN broadcast. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remotePort</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onlyReplyOnAcceptingConnections</td><td>Only request a reply if the remote system is accepting connections </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionSocketIndex</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to send on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure (unknown hostname) </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ad5667c9d47585be3a65485f9c81f7045">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ac32f687f4bbd396e326be77ac1fa77a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::PushBackPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pushAtHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts a message back in the receive queue in case you don't want to deal with it immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The pointer to the packet you want to push back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pushAtHead</td><td>True to push the packet at the start of the queue so that the next receive call returns it. False to push it at the end of the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting pushAtHead to false end makes the packets out of order. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a29c5527b07a3ddc32083d8ec1e24318b">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a46d90fb903e747f76d63eb3a96543740"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNet_1_1Packet.html">Packet</a>* RakNet::RakPeer::Receive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a message from the incoming message queue. </p>
<p>Use <a class="el" href="classRakNet_1_1RakPeer.html#ae3e053f8f77d9b2e7b7fcd03f8f9120e" title="Call this to deallocate a message returned by Receive() when you are done handling it...">DeallocatePacket()</a> to deallocate the message after you are done with it. User-thread functions, such as RPC calls and the plugin function PluginInterface::Update occur here. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if no packets are waiting to be handled, otherwise a pointer to a packet. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>COMMON MISTAKE: Be sure to call this in a loop, once per game tick, until it returns 0. If you only process one packet per game tick they will buffer up. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="RakNetTypes_8h.html" title="Types used by RakNet, most of which involve user code.">RakNetTypes.h</a> contains struct <a class="el" href="structRakNet_1_1Packet.html" title="This represents a user message from another system.">Packet</a>. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a1c50453d9dee600920aeabd62ad7c119">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a931823b7400d31ad641d6f6da1e69b88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::RemoveFromSecurityExceptionList </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a specific connection previously added via AddToSecurityExceptionList. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ip</td><td>IP address to remove. Pass 0 to remove all IP addresses. * wildcards are supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a8eba6b20dcba02453d1ed2ad77499f7d">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a1ee7422f744ab606c92b4ed4b28db40e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RakNet::RakPeer::Send </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#ae41fa01235e99dced384d137fa874a7e">PacketReliability</a>&#160;</td>
          <td class="paramname"><em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>forceReceiptNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a block of data to the specified system that you are connected to. </p>
<dl class="section note"><dt>Note</dt><dd>This function only works while connected. </dd>
<dd>
The first byte should be a message identifier starting at ID_USER_PACKET_ENUM. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Block of data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size in bytes of the data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations.">PacketPriority.h</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reliability</td><td>How reliably to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations.">PacketPriority.h</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderingChannel</td><td>When using ordered or sequenced messages, the channel to order these on. Messages are only ordered relative to other messages on the same stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemIdentifier</td><td>Who to send this packet to, or in the case of broadcasting who not to send it to. Pass either a <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structure or a <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> structure. Use UNASSIGNED_SYSTEM_ADDRESS or to specify none </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">broadcast</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceReceipt</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740" title="Gets a message from the incoming message queue.">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a543ec5be9cf5f73f5c8733d1829789f9">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ac308204d9c3f5f92ac11b30f1d183d4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RakNet::RakPeer::Send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&#160;</td>
          <td class="paramname"><em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#ae41fa01235e99dced384d137fa874a7e">PacketReliability</a>&#160;</td>
          <td class="paramname"><em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>forceReceiptNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a block of data to the specified system that you are connected to. </p>
<p>Same as the above version, but takes a <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> as input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitStream</td><td>Bitstream to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations.">PacketPriority.h</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reliability</td><td>How reliably to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations.">PacketPriority.h</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderingChannel</td><td>Channel to order the messages on, when using ordered or sequenced messages. Messages are only ordered relative to other messages on the same stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemIdentifier</td><td>System Address or <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> to send this packet to, or in the case of broadcasting, the address not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">broadcast</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceReceipt</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740" title="Gets a message from the incoming message queue.">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>
<dl class="section note"><dt>Note</dt><dd>COMMON MISTAKE: When writing the first byte, bitStream-&gt;Write((unsigned char) ID_MY_TYPE) be sure it is casted to a byte, and you are not writing a 4 byte enumeration. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a6d9a5415556a9c138854cc05c707b8e7">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a68a9c6f4db253074f3775d164e39195f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RakNet::RakPeer::SendList </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#ae41fa01235e99dced384d137fa874a7e">PacketReliability</a>&#160;</td>
          <td class="paramname"><em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&#160;</td>
          <td class="paramname"><em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>forceReceiptNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends multiple blocks of data, concatenating them automatically. </p>
<p>This is equivalent to: <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> bs; bs.WriteAlignedBytes(block1, blockLength1); bs.WriteAlignedBytes(block2, blockLength2); bs.WriteAlignedBytes(block3, blockLength3); Send(&amp;bs, ...)</p>
<p>This function only works when connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>An array of pointers to blocks of data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lengths</td><td>An array of integers indicating the length of each block of data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numParameters</td><td>Length of the arrays data and lengths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations.">PacketPriority.h</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reliability</td><td>How reliably to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations.">PacketPriority.h</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderingChannel</td><td>Channel to order the messages on, when using ordered or sequenced messages. Messages are only ordered relative to other messages on the same stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemIdentifier</td><td>System Address or <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> to send this packet to, or in the case of broadcasting, the address not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">broadcast</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceReceipt</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakNet_1_1RakPeer.html#a46d90fb903e747f76d63eb3a96543740" title="Gets a message from the incoming message queue.">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a508111f60de06beb55a65a2b811d557c">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ac3f1dcedc63156184962aa184ba69ed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SendLoopback </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Send" to yourself rather than a remote system. </p>
<p>The message will be processed through the plugins and returned to the game as usual. This function works anytime </p>
<dl class="section note"><dt>Note</dt><dd>The first byte should be a message identifier starting at ID_USER_PACKET_ENUM </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Block of data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size in bytes of the data to send. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ab8e39273dd7fb89d4b29a01bca32f82c">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a86b8b2a8d2e4edc2c1d89f6bde8b9f28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SendTTL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>connectionSocketIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message to a host, with the IP socket option TTL set to 3. </p>
<p>This message will not reach the host, but will open the router. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>The address of the remote host in dotted notation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remotePort</td><td>The port number to send to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>Max hops of datagram, set to 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionSocketIndex</td><td>userConnectionSocketIndex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Used for NAT-Punchthrough </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a700a2c9bc1414da194a35076af3b56e0">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a959a1dc3d239d3c5114bc781144d3b73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeer::SetIncomingDatagramEventHandler </td>
          <td>(</td>
          <td class="paramtype">bool(*)(RNS2RecvStruct *)&#160;</td>
          <td class="paramname"><em>_incomingDatagramEventHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a C callback to be called whenever a datagram arrives Return true from the callback to have <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> handle the datagram. Return false and <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> will ignore the datagram. This can be used to filter incoming datagrams by system, or to share a recvfrom socket with <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> RNS2RecvStruct will only remain valid for the duration of the call </p>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a6b70ebc4e2852362b366e8738624ec44">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a6d4071bbbf128604c94a27c46fa7b9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetIncomingPassword </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>passwordDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the password for the incoming connections. </p>
<p>The password must match in the call to Connect (defaults to none). Pass 0 to passwordData to specify no password. This is a way to set a low level password for all incoming connections. To selectively reject connections, implement your own scheme using <a class="el" href="classRakNet_1_1RakPeer.html#a95e3806fce8552e322236abcf105cbf9" title="Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out).">CloseConnection()</a> to remove unwanted connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">passwordData</td><td>A data block that incoming connections must match. This can be just a password, or can be a stream of data. Specify 0 for no password data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passwordDataLength</td><td>The length in bytes of passwordData </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ad18a28a99420006d020125eea1ded4ed">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ad02c3a4e4c4063771fb47fe20d4b47af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetInternalID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets your internal IP address, for platforms that do not support reading it, or to override a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress.</td><td>The address to set. Use <a class="el" href="structRakNet_1_1SystemAddress.html#ae1ad8bd3b4f24478980437476391d6ab">SystemAddress::FromString()</a> if you want to use a dotted string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>When you have multiple internal IDs, which index to set? </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ac9f163bc4b8b89db10c3f251793e0aca">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ac5e80ab105ac8124d4ee5f94bd1b316a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetLimitIPConnectionFrequency </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable allowing frequent connections from the same IP adderss. </p>
<p>This is a security measure which is disabled by default, but can be set to true to prevent attackers from using up all connection slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>True to limit connections from the same ip to at most 1 per 100 milliseconds. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a1c7d098a1d9a4613f051ae3627831af6">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a8ed81856dd81ec1cd00e17fafedee0a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetMaximumIncomingConnections </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>numberAllowed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum number of incoming connections allowed. </p>
<p>If the number of incoming connections is less than the number of players currently connected, no more players will be allowed to connect. If this is greater than the maximum number of peers allowed, it will be reduced to the maximum number of peers allowed.</p>
<p>Defaults to 0, meaning by default, nobody can connect to you </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numberAllowed</td><td>Maximum number of incoming connections allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a1f279ee0d3578de483126f6cfef282f4">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="abb8d47e41f9bc523a555d8f1bc774e4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetOccasionalPing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doPing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ping the remote systems every so often, or not. Can be called anytime. By default this is true. Recommended to leave on, because congestion control uses it to determine how often to resend lost packets. It would be true by default to prevent timestamp drift, since in the event of a clock spike, the timestamp deltas would no longer be accurate </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">doPing</td><td>True to start occasional pings. False to stop them. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#afdc6e658512d2f01d6bb211758721f21">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a2a534f1c0bb56b3c5b9b56ca8839917c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetOfflinePingResponse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the data to send along with a LAN server discovery or offline ping reply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Block of data to send, or 0 for none </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data in bytes, or 0 for none </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>length</em> should be under 400 bytes, as a security measure against flood attacks </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Ping.cpp </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a40b198325a1a4f4a1ff3b1a1741b89eb">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a9c67c61c6eebed7a4ed8bc2ea2813b56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeer::SetPerConnectionOutgoingBandwidthLimit </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxBitsPerSecond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Limits how much outgoing bandwidth can be sent per-connection. This limit does not apply to the sum of all connections! Exceeding the limit queues up outgoing traffic </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxBitsPerSecond</td><td>Maximum bits per second to send. Use 0 for unlimited (default). Once set, it takes effect immedately and persists until called again. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a95daeb743853a4406182e47668c0f33b">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a35e89d9813d6f6e7f2144a6a0437a33b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetSplitMessageProgressInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads. </p>
<p>ID_DOWNLOAD_PROGRESS is returned to indicate a new partial message chunk, roughly the MTU size, has arrived. As it can be slow or cumbersome to get this notification for every chunk, you can set the interval at which it is returned. Defaults to 0 (never return this notification). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>How many messages to use as an interval before a download progress notification is returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a4112544503b05a7b7dd2dd56adfbc648">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a46305b16342c6f5ec1c1a66623032310"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetTimeoutTime </td>
          <td>(</td>
          <td class="paramtype">RakNet::TimeMS&#160;</td>
          <td class="paramname"><em>timeMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time, in MS, to use before considering ourselves disconnected after not being able to deliver a reliable message. </p>
<p>Set the time, in MS, to use before considering ourselves disconnected after not being able to deliver a reliable message. Default time is 10,000 or 10 seconds in release and 30,000 or 30 seconds in debug. Do not set different values for different computers that are connected to each other, or you won't be able to reconnect after ID_CONNECTION_LOST </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeMS</td><td>Time, in MS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td><a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structure of the target system. Pass UNASSIGNED_SYSTEM_ADDRESS for all systems. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a49d2993d5db12a62ce88dc89700c0880">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a739faf1ea8c90aded5e11bfc105b956e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::SetUnreliableTimeout </td>
          <td>(</td>
          <td class="paramtype">RakNet::TimeMS&#160;</td>
          <td class="paramname"><em>timeoutMS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set how long to wait before giving up on sending an unreliable message. Useful if the network is clogged up. Set to 0 or less to never timeout. Defaults to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMS</td><td>How many ms to wait before simply not sending an unreliable message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a87db4b6410fce078080400f8d58328ed">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a21f59d33d16332dd8dd96d800c33d06e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeer::SetUserUpdateThread </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="classRakNet_1_1RakPeerInterface.html">RakPeerInterface</a> *, void *)&#160;</td>
          <td class="paramname"><em>_userUpdateThreadPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_userUpdateThreadData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you need code to run in the same thread as <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher that can be used f...">RakNet</a>'s update thread, this function can be used for that </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_userUpdateThreadPtr</td><td>C callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_userUpdateThreadData</td><td>Passed to C callback function </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a0832004c529aa9a0844b61eaf1374b3c">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a9251492e6d3d0538111c1d90be554b2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::ShiftIncomingTimestamp </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>systemAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the timestamp of the incoming packet to be relative to this system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data in the incoming packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemAddress</td><td>Sender of the incoming packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a6d4c16c9b489574393a39ab2f99990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::RakPeer::Shutdown </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blockDuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>orderingChannel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705c">PacketPriority</a>&#160;</td>
          <td class="paramname"><em>disconnectionNotificationPriority</em> = <code><a class="el" href="PacketPriority_8h.html#a659378374e516180f93640c79f59705cadb8ee22a232a2787f32ba28da55c43c1">LOW_PRIORITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the network threads and closes all connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockDuration</td><td>Wait time(milli seconds) for all remaining messages to go out, including ID_DISCONNECTION_NOTIFICATION. If 0, it doesn't wait at all. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderingChannel</td><td>Channel on which ID_DISCONNECTION_NOTIFICATION will be sent, if blockDuration &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disconnectionNotificationPriority</td><td>Priority of sending ID_DISCONNECTION_NOTIFICATION. If set to 0, the disconnection notification won't be sent. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#a4f4acefdc022555862fd386e31f9a22b">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a92d493cb617381a6e750f7df6e768927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StartupResult RakNet::RakPeer::Startup </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SocketDescriptor.html">SocketDescriptor</a> *&#160;</td>
          <td class="paramname"><em>socketDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>socketDescriptorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadPriority</em> = <code>-99999</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the network threads and opens the listen port. </p>
<p>You must call this before calling <a class="el" href="classRakNet_1_1RakPeer.html#a19979ff2acc15abe22785fc55c1c656c" title="Connect to the specified host (ip or domain name) and server port.">Connect()</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>On the PS3, call <a class="el" href="classRakNet_1_1RakPeer.html#a92d493cb617381a6e750f7df6e768927" title="Starts the network threads and opens the listen port.">Startup()</a> after Client_Login() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Multiple calls while already active are ignored. To call this function again with different settings, you must first call <a class="el" href="classRakNet_1_1RakPeer.html#a0a6d4c16c9b489574393a39ab2f99990" title="Stops the network threads and closes all connections.">Shutdown()</a>. </dd>
<dd>
Call SetMaximumIncomingConnections if you want to accept incoming connections. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxConnections</td><td>Maximum number of connections between this instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> and another instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>. Required so that the network can preallocate and for thread safety. A pure client would set this to 1. A pure server would set it to the number of allowed clients.A hybrid would set it to the sum of both types of connections. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localPort</td><td>The port to listen for connections on. On linux the system may be set up so thast ports under 1024 are restricted for everything but the root user. Use a higher port for maximum compatibility. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socketDescriptors</td><td>An array of <a class="el" href="structRakNet_1_1SocketDescriptor.html" title="Describes the local socket to use for RakPeer::Startup.">SocketDescriptor</a> structures to force <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher that can be used f...">RakNet</a> to listen on a particular IP address or port (or both). Each <a class="el" href="structRakNet_1_1SocketDescriptor.html" title="Describes the local socket to use for RakPeer::Startup.">SocketDescriptor</a> will represent one unique socket. Do not pass redundant structures. To listen on a specific port, you can pass SocketDescriptor(myPort,0); such as for a server. For a client, it is usually OK to just pass SocketDescriptor(); However, on the XBOX be sure to use IPPROTO_VDP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socketDescriptorCount</td><td>The size of the <em>socketDescriptors</em> array. Pass 1 if you are not sure what to pass. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadPriority</td><td>Passed to the thread creation routine. Use THREAD_PRIORITY_NORMAL for Windows. For Linux based systems, you MUST pass something reasonable based on the thread priorities for your application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RAKNET_STARTED on success, otherwise appropriate failure enumeration. </dd></dl>

<p>Implements <a class="el" href="classRakNet_1_1RakPeerInterface.html#ad360d12ceb7d7448b598c451fffd2d9c">RakNet::RakPeerInterface</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad8cab96454717bfcbc2cfda6f88d8cc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RemoteSystemStruct** RakNet::RakPeer::activeSystemList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>activeSystemList holds a list of pointers and is preallocated to be the same size as remoteSystemList. It is updated only by the network thread, but read by both threads When the isActive member of RemoteSystemStruct is set to true or false, that system is added to this list of pointers Threadsafe because RemoteSystemStruct is preallocated, and the list is only added to, not removed from </p>

</div>
</div>
<a class="anchor" id="a9d820f9f09600401b3689a599242832a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::RakPeer::allowConnectionResponseIPMigration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How long it has been since things were updated by a call to receiveUpdate thread uses this to determine how long to sleep for. </p>
<p>True to allow connection accepted packets from anyone. False to only allow these packets from servers we requested a connection to. </p>

</div>
</div>
<a class="anchor" id="a031ec9044cab71ff6f0ecc3b60e21b76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RakNet::RakPeer::bytesSentPerSecond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of people we have tried to connect to recently. </p>
<p>Data that both the client and the server needs </p>

</div>
</div>
<a class="anchor" id="a6244b23254ae6e95302b5060b3f1bc0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RakNet::RakPeer::maximumIncomingConnections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the maximum number of peers able to connect, including reserved connection slots for pings, etc. </p>
<p>Store the maximum incoming connection allowed </p>

</div>
</div>
<a class="anchor" id="a9faf5bd4ea7dca603f967b6ee1ed40d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">* unsigned int RakNet::RakPeer::maximumNumberOfPeers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the maximum number of peers allowed to connect. </p>
<p>Do we occasionally ping the other systems? </p>

</div>
</div>
<a class="anchor" id="a433a287f35dd77985ae4ac579e6adf76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RemoteSystemStruct* RakNet::RakPeer::remoteSystemList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an array of pointers to RemoteSystemStruct This allows us to preallocate the list when starting, so we don't have to allocate or delete at runtime. Another benefit is that is lets us add and remove active players simply by setting systemAddress and moving elements in the list by copying pointers variables without affecting running threads, even if they are in the reliability layer </p>

</div>
</div>
<a class="anchor" id="aa4972e4a0c0573671148f33ca2c9ebd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRakNet_1_1SimpleMutex.html">SimpleMutex</a> RakNet::RakPeer::sendReceiptSerialMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is used to return a number to the user when they call Send identifying the message This number will be returned back with ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS and is only returned with the reliability types that contain RECEIPT in the name </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/temp/RakNet_PC/Source/<a class="el" href="RakPeer_8h.html">RakPeer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 2 2014 20:10:29 for RakNet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
