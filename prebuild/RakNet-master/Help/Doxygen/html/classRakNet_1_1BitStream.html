<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RakNet: RakNet::BitStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RakNet
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRakNet.html">RakNet</a></li><li class="navelem"><a class="el" href="classRakNet_1_1BitStream.html">BitStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRakNet_1_1BitStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RakNet::BitStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;BitStream.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1aeb4088ac7a611c9eebc629df86890c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aeb4088ac7a611c9eebc629df86890c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1aeb4088ac7a611c9eebc629df86890c">BitStream</a> ()</td></tr>
<tr class="memdesc:a1aeb4088ac7a611c9eebc629df86890c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr class="separator:a1aeb4088ac7a611c9eebc629df86890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b1c7ce200c4815bd2a42d454244bb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a47b1c7ce200c4815bd2a42d454244bb4">BitStream</a> (const unsigned int initialBytesToAllocate)</td></tr>
<tr class="memdesc:a47b1c7ce200c4815bd2a42d454244bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the bitstream, with some number of bytes to immediately allocate.  <a href="#a47b1c7ce200c4815bd2a42d454244bb4"></a><br/></td></tr>
<tr class="separator:a47b1c7ce200c4815bd2a42d454244bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a200eaf5b379cad2e30d5de15a2c9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a04a200eaf5b379cad2e30d5de15a2c9a">BitStream</a> (unsigned char *_data, const unsigned int lengthInBytes, bool _copyData)</td></tr>
<tr class="memdesc:a04a200eaf5b379cad2e30d5de15a2c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a>, immediately setting the data it contains to a predefined pointer.  <a href="#a04a200eaf5b379cad2e30d5de15a2c9a"></a><br/></td></tr>
<tr class="separator:a04a200eaf5b379cad2e30d5de15a2c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60690472e9540e6c3f4b69961e19440f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60690472e9540e6c3f4b69961e19440f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a60690472e9540e6c3f4b69961e19440f">Reset</a> (void)</td></tr>
<tr class="memdesc:a60690472e9540e6c3f4b69961e19440f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the bitstream for reuse. <br/></td></tr>
<tr class="separator:a60690472e9540e6c3f4b69961e19440f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf95af1e57ce9a5386ab6a620ffd593b"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:adf95af1e57ce9a5386ab6a620ffd593b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#adf95af1e57ce9a5386ab6a620ffd593b">Serialize</a> (bool writeToBitstream, templateType &amp;inOutTemplateVar)</td></tr>
<tr class="memdesc:adf95af1e57ce9a5386ab6a620ffd593b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#adf95af1e57ce9a5386ab6a620ffd593b"></a><br/></td></tr>
<tr class="separator:adf95af1e57ce9a5386ab6a620ffd593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aab79184deb91907b7bc8934ca45bc2"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a6aab79184deb91907b7bc8934ca45bc2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a6aab79184deb91907b7bc8934ca45bc2">SerializeDelta</a> (bool writeToBitstream, templateType &amp;inOutCurrentValue, const templateType &amp;lastValue)</td></tr>
<tr class="memdesc:a6aab79184deb91907b7bc8934ca45bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#a6aab79184deb91907b7bc8934ca45bc2"></a><br/></td></tr>
<tr class="separator:a6aab79184deb91907b7bc8934ca45bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cc6838ab5b4477ac7a4021bb1356c3"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ab1cc6838ab5b4477ac7a4021bb1356c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ab1cc6838ab5b4477ac7a4021bb1356c3">SerializeDelta</a> (bool writeToBitstream, templateType &amp;inOutCurrentValue)</td></tr>
<tr class="memdesc:ab1cc6838ab5b4477ac7a4021bb1356c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional version of SerializeDelta when you don't know what the last value is, or there is no last value.  <a href="#ab1cc6838ab5b4477ac7a4021bb1356c3"></a><br/></td></tr>
<tr class="separator:ab1cc6838ab5b4477ac7a4021bb1356c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdf11345fb4e998d411b87426648a36"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a5fdf11345fb4e998d411b87426648a36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a5fdf11345fb4e998d411b87426648a36">SerializeCompressed</a> (bool writeToBitstream, templateType &amp;inOutTemplateVar)</td></tr>
<tr class="memdesc:a5fdf11345fb4e998d411b87426648a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#a5fdf11345fb4e998d411b87426648a36"></a><br/></td></tr>
<tr class="separator:a5fdf11345fb4e998d411b87426648a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1991ab41173693f8e9c0e78c9ad2a3"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a8a1991ab41173693f8e9c0e78c9ad2a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a8a1991ab41173693f8e9c0e78c9ad2a3">SerializeCompressedDelta</a> (bool writeToBitstream, templateType &amp;inOutCurrentValue, const templateType &amp;lastValue)</td></tr>
<tr class="memdesc:a8a1991ab41173693f8e9c0e78c9ad2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#a8a1991ab41173693f8e9c0e78c9ad2a3"></a><br/></td></tr>
<tr class="separator:a8a1991ab41173693f8e9c0e78c9ad2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca9bf6bb61905e43003097d7af79fe"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ad1ca9bf6bb61905e43003097d7af79fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad1ca9bf6bb61905e43003097d7af79fe">SerializeCompressedDelta</a> (bool writeToBitstream, templateType &amp;inOutTemplateVar)</td></tr>
<tr class="memdesc:ad1ca9bf6bb61905e43003097d7af79fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save as SerializeCompressedDelta(templateType &amp;currentValue, const templateType &amp;lastValue) when we have an unknown second parameter.  <a href="#ad1ca9bf6bb61905e43003097d7af79fe"></a><br/></td></tr>
<tr class="separator:ad1ca9bf6bb61905e43003097d7af79fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e3ec310191a69b9bba227a72e65537"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad2e3ec310191a69b9bba227a72e65537">Serialize</a> (bool writeToBitstream, char *inOutByteArray, const unsigned int numberOfBytes)</td></tr>
<tr class="memdesc:ad2e3ec310191a69b9bba227a72e65537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize an array or casted stream or raw data. This does NOT do endian swapping.  <a href="#ad2e3ec310191a69b9bba227a72e65537"></a><br/></td></tr>
<tr class="separator:ad2e3ec310191a69b9bba227a72e65537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aebab1c543acd21742f380c95255365"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1aebab1c543acd21742f380c95255365">SerializeFloat16</a> (bool writeToBitstream, float &amp;inOutFloat, float floatMin, float floatMax)</td></tr>
<tr class="memdesc:a1aebab1c543acd21742f380c95255365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>.  <a href="#a1aebab1c543acd21742f380c95255365"></a><br/></td></tr>
<tr class="separator:a1aebab1c543acd21742f380c95255365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3615fc88c34f910085e0f94a6231926b"><td class="memTemplParams" colspan="2">template&lt;class serializationType , class sourceType &gt; </td></tr>
<tr class="memitem:a3615fc88c34f910085e0f94a6231926b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a3615fc88c34f910085e0f94a6231926b">SerializeCasted</a> (bool writeToBitstream, sourceType &amp;value)</td></tr>
<tr class="separator:a3615fc88c34f910085e0f94a6231926b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfb0266bf435e0bba8b221f089a4aec"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a9cfb0266bf435e0bba8b221f089a4aec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a9cfb0266bf435e0bba8b221f089a4aec">SerializeBitsFromIntegerRange</a> (bool writeToBitstream, templateType &amp;value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)</td></tr>
<tr class="separator:a9cfb0266bf435e0bba8b221f089a4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e811bf0d8447faedc96261920944cd"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a91e811bf0d8447faedc96261920944cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a91e811bf0d8447faedc96261920944cd">SerializeBitsFromIntegerRange</a> (bool writeToBitstream, templateType &amp;value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)</td></tr>
<tr class="separator:a91e811bf0d8447faedc96261920944cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e357618f04ee5166fe74a9738a28b82"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a1e357618f04ee5166fe74a9738a28b82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1e357618f04ee5166fe74a9738a28b82">SerializeNormVector</a> (bool writeToBitstream, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>
<tr class="memdesc:a1e357618f04ee5166fe74a9738a28b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  <a href="#a1e357618f04ee5166fe74a9738a28b82"></a><br/></td></tr>
<tr class="separator:a1e357618f04ee5166fe74a9738a28b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39a138bf295277ed6f804d6d2d5d9fb"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ad39a138bf295277ed6f804d6d2d5d9fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad39a138bf295277ed6f804d6d2d5d9fb">SerializeVector</a> (bool writeToBitstream, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>
<tr class="memdesc:ad39a138bf295277ed6f804d6d2d5d9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize a vector, using 10 bytes instead of 12.  <a href="#ad39a138bf295277ed6f804d6d2d5d9fb"></a><br/></td></tr>
<tr class="separator:ad39a138bf295277ed6f804d6d2d5d9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03953490ce2c0fbc5cebb67fdebdb75d"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a03953490ce2c0fbc5cebb67fdebdb75d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a03953490ce2c0fbc5cebb67fdebdb75d">SerializeNormQuat</a> (bool writeToBitstream, templateType &amp;w, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>
<tr class="memdesc:a03953490ce2c0fbc5cebb67fdebdb75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy.  <a href="#a03953490ce2c0fbc5cebb67fdebdb75d"></a><br/></td></tr>
<tr class="separator:a03953490ce2c0fbc5cebb67fdebdb75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45063562f20be6154c17bef523ac846"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ad45063562f20be6154c17bef523ac846"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad45063562f20be6154c17bef523ac846">SerializeOrthMatrix</a> (bool writeToBitstream, templateType &amp;m00, templateType &amp;m01, templateType &amp;m02, templateType &amp;m10, templateType &amp;m11, templateType &amp;m12, templateType &amp;m20, templateType &amp;m21, templateType &amp;m22)</td></tr>
<tr class="memdesc:ad45063562f20be6154c17bef523ac846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.  <a href="#ad45063562f20be6154c17bef523ac846"></a><br/></td></tr>
<tr class="separator:ad45063562f20be6154c17bef523ac846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c0f31d16b211a2aa7cdb3ec594cbf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a25c0f31d16b211a2aa7cdb3ec594cbf9">SerializeBits</a> (bool writeToBitstream, unsigned char *inOutByteArray, const BitSize_t numberOfBitsToSerialize, const bool rightAlignedBits=true)</td></tr>
<tr class="memdesc:a25c0f31d16b211a2aa7cdb3ec594cbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional serialize/deserialize numberToSerialize bits to/from the input.  <a href="#a25c0f31d16b211a2aa7cdb3ec594cbf9"></a><br/></td></tr>
<tr class="separator:a25c0f31d16b211a2aa7cdb3ec594cbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0d0bb96142a302385613d44e66558b"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:acc0d0bb96142a302385613d44e66558b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#acc0d0bb96142a302385613d44e66558b">Write</a> (const templateType &amp;inTemplateVar)</td></tr>
<tr class="memdesc:acc0d0bb96142a302385613d44e66558b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#acc0d0bb96142a302385613d44e66558b"></a><br/></td></tr>
<tr class="separator:acc0d0bb96142a302385613d44e66558b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa6ce96e75cf8339c29d7101a5bdb3a"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a2aa6ce96e75cf8339c29d7101a5bdb3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a2aa6ce96e75cf8339c29d7101a5bdb3a">WritePtr</a> (templateType *inTemplateVar)</td></tr>
<tr class="memdesc:a2aa6ce96e75cf8339c29d7101a5bdb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the dereferenced pointer to any integral type to a bitstream.  <a href="#a2aa6ce96e75cf8339c29d7101a5bdb3a"></a><br/></td></tr>
<tr class="separator:a2aa6ce96e75cf8339c29d7101a5bdb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8613fe1f3d998a125fd2962c905e67"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:abd8613fe1f3d998a125fd2962c905e67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#abd8613fe1f3d998a125fd2962c905e67">WriteDelta</a> (const templateType &amp;currentValue, const templateType &amp;lastValue)</td></tr>
<tr class="memdesc:abd8613fe1f3d998a125fd2962c905e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#abd8613fe1f3d998a125fd2962c905e67"></a><br/></td></tr>
<tr class="separator:abd8613fe1f3d998a125fd2962c905e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09461811793e5719e574d47bc513ac8a"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a09461811793e5719e574d47bc513ac8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a09461811793e5719e574d47bc513ac8a">WriteDelta</a> (const templateType &amp;currentValue)</td></tr>
<tr class="memdesc:a09461811793e5719e574d47bc513ac8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteDelta when you don't know what the last value is, or there is no last value.  <a href="#a09461811793e5719e574d47bc513ac8a"></a><br/></td></tr>
<tr class="separator:a09461811793e5719e574d47bc513ac8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32700a1c6f26d15890470dba1532ef4"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ac32700a1c6f26d15890470dba1532ef4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ac32700a1c6f26d15890470dba1532ef4">WriteCompressed</a> (const templateType &amp;inTemplateVar)</td></tr>
<tr class="memdesc:ac32700a1c6f26d15890470dba1532ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#ac32700a1c6f26d15890470dba1532ef4"></a><br/></td></tr>
<tr class="separator:ac32700a1c6f26d15890470dba1532ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8aab299cf0eb021802ed8671844948"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a1f8aab299cf0eb021802ed8671844948"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1f8aab299cf0eb021802ed8671844948">WriteCompressedDelta</a> (const templateType &amp;currentValue, const templateType &amp;lastValue)</td></tr>
<tr class="memdesc:a1f8aab299cf0eb021802ed8671844948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#a1f8aab299cf0eb021802ed8671844948"></a><br/></td></tr>
<tr class="separator:a1f8aab299cf0eb021802ed8671844948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5b260229e8b942a7909935d3a34340"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a5b260229e8b942a7909935d3a34340"></a>
template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a3a5b260229e8b942a7909935d3a34340"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a3a5b260229e8b942a7909935d3a34340">WriteCompressedDelta</a> (const templateType &amp;currentValue)</td></tr>
<tr class="memdesc:a3a5b260229e8b942a7909935d3a34340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save as <a class="el" href="classRakNet_1_1BitStream.html#a1f8aab299cf0eb021802ed8671844948" title="Write any integral type to a bitstream.">WriteCompressedDelta(const templateType &amp;currentValue, const templateType &amp;lastValue)</a> when we have an unknown second parameter. <br/></td></tr>
<tr class="separator:a3a5b260229e8b942a7909935d3a34340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865bd246780b10e2b9d7c1bc13044343"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a865bd246780b10e2b9d7c1bc13044343"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a865bd246780b10e2b9d7c1bc13044343">Read</a> (templateType &amp;outTemplateVar)</td></tr>
<tr class="memdesc:a865bd246780b10e2b9d7c1bc13044343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#a865bd246780b10e2b9d7c1bc13044343"></a><br/></td></tr>
<tr class="separator:a865bd246780b10e2b9d7c1bc13044343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19904647a86e54757a4a740d1275b00"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ad19904647a86e54757a4a740d1275b00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad19904647a86e54757a4a740d1275b00">ReadDelta</a> (templateType &amp;outTemplateVar)</td></tr>
<tr class="memdesc:ad19904647a86e54757a4a740d1275b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#ad19904647a86e54757a4a740d1275b00"></a><br/></td></tr>
<tr class="separator:ad19904647a86e54757a4a740d1275b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc394f439d9112328f92e7b22d116e5a"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:acc394f439d9112328f92e7b22d116e5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#acc394f439d9112328f92e7b22d116e5a">ReadCompressed</a> (templateType &amp;outTemplateVar)</td></tr>
<tr class="memdesc:acc394f439d9112328f92e7b22d116e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#acc394f439d9112328f92e7b22d116e5a"></a><br/></td></tr>
<tr class="separator:acc394f439d9112328f92e7b22d116e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099c2c8fb1b5321aacb5bded88a8f300"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a099c2c8fb1b5321aacb5bded88a8f300"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a099c2c8fb1b5321aacb5bded88a8f300">ReadCompressedDelta</a> (templateType &amp;outTemplateVar)</td></tr>
<tr class="memdesc:a099c2c8fb1b5321aacb5bded88a8f300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#a099c2c8fb1b5321aacb5bded88a8f300"></a><br/></td></tr>
<tr class="separator:a099c2c8fb1b5321aacb5bded88a8f300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025f73d57a5ebe8fb6393eca5f3616df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a025f73d57a5ebe8fb6393eca5f3616df">Read</a> (<a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *bitStream, BitSize_t numberOfBits)</td></tr>
<tr class="memdesc:a025f73d57a5ebe8fb6393eca5f3616df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one bitstream to another.  <a href="#a025f73d57a5ebe8fb6393eca5f3616df"></a><br/></td></tr>
<tr class="separator:a025f73d57a5ebe8fb6393eca5f3616df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6e2624a5960f9ac40d4072a6e607e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a0c6e2624a5960f9ac40d4072a6e607e5">Write</a> (const char *inputByteArray, const unsigned int numberOfBytes)</td></tr>
<tr class="memdesc:a0c6e2624a5960f9ac40d4072a6e607e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array or casted stream or raw data. This does NOT do endian swapping.  <a href="#a0c6e2624a5960f9ac40d4072a6e607e5"></a><br/></td></tr>
<tr class="separator:a0c6e2624a5960f9ac40d4072a6e607e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26624b5669df1c38f6dd6dabf4c1b769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a26624b5669df1c38f6dd6dabf4c1b769">Write</a> (<a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *bitStream, BitSize_t numberOfBits)</td></tr>
<tr class="memdesc:a26624b5669df1c38f6dd6dabf4c1b769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one bitstream to another.  <a href="#a26624b5669df1c38f6dd6dabf4c1b769"></a><br/></td></tr>
<tr class="separator:a26624b5669df1c38f6dd6dabf4c1b769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b37ff9ba34ce6f98c8521710ba51366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a8b37ff9ba34ce6f98c8521710ba51366">WriteFloat16</a> (float x, float floatMin, float floatMax)</td></tr>
<tr class="memdesc:a8b37ff9ba34ce6f98c8521710ba51366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>.  <a href="#a8b37ff9ba34ce6f98c8521710ba51366"></a><br/></td></tr>
<tr class="separator:a8b37ff9ba34ce6f98c8521710ba51366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ecfa7830db77b09a1d121bffdccb67"><td class="memTemplParams" colspan="2">template&lt;class serializationType , class sourceType &gt; </td></tr>
<tr class="memitem:a13ecfa7830db77b09a1d121bffdccb67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a13ecfa7830db77b09a1d121bffdccb67">WriteCasted</a> (const sourceType &amp;value)</td></tr>
<tr class="separator:a13ecfa7830db77b09a1d121bffdccb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9345107dfe25bfe800aa17826a77b4"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a7e9345107dfe25bfe800aa17826a77b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a7e9345107dfe25bfe800aa17826a77b4">WriteBitsFromIntegerRange</a> (const templateType value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)</td></tr>
<tr class="separator:a7e9345107dfe25bfe800aa17826a77b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0064de4e5e34478bdf43623c8d41a1"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a4f0064de4e5e34478bdf43623c8d41a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a4f0064de4e5e34478bdf43623c8d41a1">WriteBitsFromIntegerRange</a> (const templateType value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)</td></tr>
<tr class="separator:a4f0064de4e5e34478bdf43623c8d41a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac37adc6bd171459103131d788fdebf7"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:aac37adc6bd171459103131d788fdebf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aac37adc6bd171459103131d788fdebf7">WriteNormVector</a> (templateType x, templateType y, templateType z)</td></tr>
<tr class="memdesc:aac37adc6bd171459103131d788fdebf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  <a href="#aac37adc6bd171459103131d788fdebf7"></a><br/></td></tr>
<tr class="separator:aac37adc6bd171459103131d788fdebf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffa67542bbe1e407a565652becb408f"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a0ffa67542bbe1e407a565652becb408f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a0ffa67542bbe1e407a565652becb408f">WriteVector</a> (templateType x, templateType y, templateType z)</td></tr>
<tr class="memdesc:a0ffa67542bbe1e407a565652becb408f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a vector, using 10 bytes instead of 12.  <a href="#a0ffa67542bbe1e407a565652becb408f"></a><br/></td></tr>
<tr class="separator:a0ffa67542bbe1e407a565652becb408f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb96f0dce8b1a864799d02211cf34d8b"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:acb96f0dce8b1a864799d02211cf34d8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#acb96f0dce8b1a864799d02211cf34d8b">WriteNormQuat</a> (templateType w, templateType x, templateType y, templateType z)</td></tr>
<tr class="memdesc:acb96f0dce8b1a864799d02211cf34d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy.  <a href="#acb96f0dce8b1a864799d02211cf34d8b"></a><br/></td></tr>
<tr class="separator:acb96f0dce8b1a864799d02211cf34d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb06e701aa336f41c314b88ae27c60bc"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:adb06e701aa336f41c314b88ae27c60bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#adb06e701aa336f41c314b88ae27c60bc">WriteOrthMatrix</a> (templateType m00, templateType m01, templateType m02, templateType m10, templateType m11, templateType m12, templateType m20, templateType m21, templateType m22)</td></tr>
<tr class="memdesc:adb06e701aa336f41c314b88ae27c60bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.  <a href="#adb06e701aa336f41c314b88ae27c60bc"></a><br/></td></tr>
<tr class="separator:adb06e701aa336f41c314b88ae27c60bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b53ddc6f6bc9a1e0c01cb677a3c6d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a25b53ddc6f6bc9a1e0c01cb677a3c6d1">Read</a> (char *output, const unsigned int numberOfBytes)</td></tr>
<tr class="memdesc:a25b53ddc6f6bc9a1e0c01cb677a3c6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array or casted stream of byte.  <a href="#a25b53ddc6f6bc9a1e0c01cb677a3c6d1"></a><br/></td></tr>
<tr class="separator:a25b53ddc6f6bc9a1e0c01cb677a3c6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8275d390e2114d55449bb4ae2d01d62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#af8275d390e2114d55449bb4ae2d01d62">ReadFloat16</a> (float &amp;outFloat, float floatMin, float floatMax)</td></tr>
<tr class="memdesc:af8275d390e2114d55449bb4ae2d01d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>.  <a href="#af8275d390e2114d55449bb4ae2d01d62"></a><br/></td></tr>
<tr class="separator:af8275d390e2114d55449bb4ae2d01d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab282a3cea68401414d8569f997a5367"><td class="memTemplParams" colspan="2">template&lt;class serializationType , class sourceType &gt; </td></tr>
<tr class="memitem:aab282a3cea68401414d8569f997a5367"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aab282a3cea68401414d8569f997a5367">ReadCasted</a> (sourceType &amp;value)</td></tr>
<tr class="separator:aab282a3cea68401414d8569f997a5367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620645af65289abfb244270261060df9"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a620645af65289abfb244270261060df9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a620645af65289abfb244270261060df9">ReadBitsFromIntegerRange</a> (templateType &amp;value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)</td></tr>
<tr class="separator:a620645af65289abfb244270261060df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ebc24f3cf193f77d7cd4c3e1eaf22f"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ae2ebc24f3cf193f77d7cd4c3e1eaf22f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ae2ebc24f3cf193f77d7cd4c3e1eaf22f">ReadBitsFromIntegerRange</a> (templateType &amp;value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)</td></tr>
<tr class="separator:ae2ebc24f3cf193f77d7cd4c3e1eaf22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9b48a07801cb8628dd5523a275a917"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:aaa9b48a07801cb8628dd5523a275a917"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aaa9b48a07801cb8628dd5523a275a917">ReadNormVector</a> (templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>
<tr class="memdesc:aaa9b48a07801cb8628dd5523a275a917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  <a href="#aaa9b48a07801cb8628dd5523a275a917"></a><br/></td></tr>
<tr class="separator:aaa9b48a07801cb8628dd5523a275a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0d350e53bc70d3d24def9b6bbf62ba"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a1c0d350e53bc70d3d24def9b6bbf62ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1c0d350e53bc70d3d24def9b6bbf62ba">ReadVector</a> (templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>
<tr class="memdesc:a1c0d350e53bc70d3d24def9b6bbf62ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 3 floats or doubles, using 10 bytes, where those float or doubles comprise a vector.  <a href="#a1c0d350e53bc70d3d24def9b6bbf62ba"></a><br/></td></tr>
<tr class="separator:a1c0d350e53bc70d3d24def9b6bbf62ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ec569c23a95f8ee46ec36c4b8303da"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:ad6ec569c23a95f8ee46ec36c4b8303da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad6ec569c23a95f8ee46ec36c4b8303da">ReadNormQuat</a> (templateType &amp;w, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>
<tr class="memdesc:ad6ec569c23a95f8ee46ec36c4b8303da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes.  <a href="#ad6ec569c23a95f8ee46ec36c4b8303da"></a><br/></td></tr>
<tr class="separator:ad6ec569c23a95f8ee46ec36c4b8303da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542c53992e9896cddb7a1bd96bce06ff"><td class="memTemplParams" colspan="2">template&lt;class templateType &gt; </td></tr>
<tr class="memitem:a542c53992e9896cddb7a1bd96bce06ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a542c53992e9896cddb7a1bd96bce06ff">ReadOrthMatrix</a> (templateType &amp;m00, templateType &amp;m01, templateType &amp;m02, templateType &amp;m10, templateType &amp;m11, templateType &amp;m12, templateType &amp;m20, templateType &amp;m21, templateType &amp;m22)</td></tr>
<tr class="memdesc:a542c53992e9896cddb7a1bd96bce06ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an orthogonal matrix from a quaternion, reading 3 components of the quaternion in 2 bytes each and extrapolatig the 4th.  <a href="#a542c53992e9896cddb7a1bd96bce06ff"></a><br/></td></tr>
<tr class="separator:a542c53992e9896cddb7a1bd96bce06ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa64a4efffbfc9f5e527061bb82126b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa64a4efffbfc9f5e527061bb82126b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aaa64a4efffbfc9f5e527061bb82126b8">ResetReadPointer</a> (void)</td></tr>
<tr class="memdesc:aaa64a4efffbfc9f5e527061bb82126b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the read pointer back to the beginning of your data. <br/></td></tr>
<tr class="separator:aaa64a4efffbfc9f5e527061bb82126b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9254b23b2873496aab84d2637d7488ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9254b23b2873496aab84d2637d7488ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a9254b23b2873496aab84d2637d7488ee">ResetWritePointer</a> (void)</td></tr>
<tr class="memdesc:a9254b23b2873496aab84d2637d7488ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the write pointer back to the beginning of your data. <br/></td></tr>
<tr class="separator:a9254b23b2873496aab84d2637d7488ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8492d958d2527a14813cc1a22a71b83a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8492d958d2527a14813cc1a22a71b83a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a8492d958d2527a14813cc1a22a71b83a">AssertStreamEmpty</a> (void)</td></tr>
<tr class="memdesc:a8492d958d2527a14813cc1a22a71b83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is good to call when you are done with the stream to make sure you didn't leave any data left over void. <br/></td></tr>
<tr class="separator:a8492d958d2527a14813cc1a22a71b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cf3e238c0925fdbeb7b792a2f79626"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74cf3e238c0925fdbeb7b792a2f79626"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a74cf3e238c0925fdbeb7b792a2f79626">PrintBits</a> (char *out) const </td></tr>
<tr class="memdesc:a74cf3e238c0925fdbeb7b792a2f79626"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAKNET_DEBUG_PRINTF the bits in the stream. Great for debugging. <br/></td></tr>
<tr class="separator:a74cf3e238c0925fdbeb7b792a2f79626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952b3b3007b120fdd143f87311a98a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1952b3b3007b120fdd143f87311a98a2">IgnoreBits</a> (const BitSize_t numberOfBits)</td></tr>
<tr class="memdesc:a1952b3b3007b120fdd143f87311a98a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore data we don't intend to read.  <a href="#a1952b3b3007b120fdd143f87311a98a2"></a><br/></td></tr>
<tr class="separator:a1952b3b3007b120fdd143f87311a98a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26310ba75436c24a1272e65da6a90a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a26310ba75436c24a1272e65da6a90a1e">IgnoreBytes</a> (const unsigned int numberOfBytes)</td></tr>
<tr class="memdesc:a26310ba75436c24a1272e65da6a90a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore data we don't intend to read.  <a href="#a26310ba75436c24a1272e65da6a90a1e"></a><br/></td></tr>
<tr class="separator:a26310ba75436c24a1272e65da6a90a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56ebc6a1381369ddc2a6d7821512d7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aa56ebc6a1381369ddc2a6d7821512d7e">SetWriteOffset</a> (const BitSize_t offset)</td></tr>
<tr class="memdesc:aa56ebc6a1381369ddc2a6d7821512d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the write pointer to a position on the array.  <a href="#aa56ebc6a1381369ddc2a6d7821512d7e"></a><br/></td></tr>
<tr class="separator:aa56ebc6a1381369ddc2a6d7821512d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403d4d6ada2fd98bc78943124fc1276a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a403d4d6ada2fd98bc78943124fc1276a"></a>
BitSize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a403d4d6ada2fd98bc78943124fc1276a">GetNumberOfBitsUsed</a> (void) const </td></tr>
<tr class="memdesc:a403d4d6ada2fd98bc78943124fc1276a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bits of the stream. <br/></td></tr>
<tr class="separator:a403d4d6ada2fd98bc78943124fc1276a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98478b4da2e29d5923c0ae80bda76f97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98478b4da2e29d5923c0ae80bda76f97"></a>
BitSize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a98478b4da2e29d5923c0ae80bda76f97">GetNumberOfBytesUsed</a> (void) const </td></tr>
<tr class="memdesc:a98478b4da2e29d5923c0ae80bda76f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes of the stream. <br/></td></tr>
<tr class="separator:a98478b4da2e29d5923c0ae80bda76f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fa9312c1d16efd18059e38569c4bb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4fa9312c1d16efd18059e38569c4bb1"></a>
BitSize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ab4fa9312c1d16efd18059e38569c4bb1">GetReadOffset</a> (void) const </td></tr>
<tr class="memdesc:ab4fa9312c1d16efd18059e38569c4bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits into the stream that we have read. <br/></td></tr>
<tr class="separator:ab4fa9312c1d16efd18059e38569c4bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a63454d1e1f26c659c3ebb65bd76ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7a63454d1e1f26c659c3ebb65bd76ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad7a63454d1e1f26c659c3ebb65bd76ba">SetReadOffset</a> (const BitSize_t newReadOffset)</td></tr>
<tr class="memdesc:ad7a63454d1e1f26c659c3ebb65bd76ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the read bit index. <br/></td></tr>
<tr class="separator:ad7a63454d1e1f26c659c3ebb65bd76ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a853a0e55000f302b3af27d20ae1dea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a853a0e55000f302b3af27d20ae1dea"></a>
BitSize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a7a853a0e55000f302b3af27d20ae1dea">GetNumberOfUnreadBits</a> (void) const </td></tr>
<tr class="memdesc:a7a853a0e55000f302b3af27d20ae1dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits left in the stream that haven't been read. <br/></td></tr>
<tr class="separator:a7a853a0e55000f302b3af27d20ae1dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8471c4c11d6cc08bf713c8f8273d86b0"><td class="memItemLeft" align="right" valign="top">BitSize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a8471c4c11d6cc08bf713c8f8273d86b0">CopyData</a> (unsigned char **_data) const </td></tr>
<tr class="memdesc:a8471c4c11d6cc08bf713c8f8273d86b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of the internal data for you <em>_data</em> will point to the stream. Partial bytes are left aligned.  <a href="#a8471c4c11d6cc08bf713c8f8273d86b0"></a><br/></td></tr>
<tr class="separator:a8471c4c11d6cc08bf713c8f8273d86b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e201444796178e5074083b6d09bd221"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a2e201444796178e5074083b6d09bd221">GetData</a> (void) const </td></tr>
<tr class="separator:a2e201444796178e5074083b6d09bd221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6357c08afed23e2e857c418cbbb3a29a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a6357c08afed23e2e857c418cbbb3a29a">WriteBits</a> (const unsigned char *inByteArray, BitSize_t numberOfBitsToWrite, const bool rightAlignedBits=true)</td></tr>
<tr class="memdesc:a6357c08afed23e2e857c418cbbb3a29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write numberToWrite bits from the input source.  <a href="#a6357c08afed23e2e857c418cbbb3a29a"></a><br/></td></tr>
<tr class="separator:a6357c08afed23e2e857c418cbbb3a29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8b1c73408fc1e4e8088ca858c0f7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#abcd8b1c73408fc1e4e8088ca858c0f7a">WriteAlignedBytes</a> (const unsigned char *inByteArray, const unsigned int numberOfBytesToWrite)</td></tr>
<tr class="memdesc:abcd8b1c73408fc1e4e8088ca858c0f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align the bitstream to the byte boundary and then write the specified number of bits.  <a href="#abcd8b1c73408fc1e4e8088ca858c0f7a"></a><br/></td></tr>
<tr class="separator:abcd8b1c73408fc1e4e8088ca858c0f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae285a7aaba6f50b5ce8e5bf4163639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a2ae285a7aaba6f50b5ce8e5bf4163639">WriteAlignedBytesSafe</a> (const char *inByteArray, const unsigned int inputLength, const unsigned int maxBytesToWrite)</td></tr>
<tr class="memdesc:a2ae285a7aaba6f50b5ce8e5bf4163639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite.  <a href="#a2ae285a7aaba6f50b5ce8e5bf4163639"></a><br/></td></tr>
<tr class="separator:a2ae285a7aaba6f50b5ce8e5bf4163639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543023e7a84ecbf58a777aa2071b444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1543023e7a84ecbf58a777aa2071b444">ReadAlignedBytes</a> (unsigned char *inOutByteArray, const unsigned int numberOfBytesToRead)</td></tr>
<tr class="memdesc:a1543023e7a84ecbf58a777aa2071b444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bits, starting at the next aligned bits.  <a href="#a1543023e7a84ecbf58a777aa2071b444"></a><br/></td></tr>
<tr class="separator:a1543023e7a84ecbf58a777aa2071b444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcd3b86367691647f66a81241358fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a2fcd3b86367691647f66a81241358fe7">ReadAlignedBytesSafe</a> (char *inOutByteArray, int &amp;inputLength, const int maxBytesToRead)</td></tr>
<tr class="memdesc:a2fcd3b86367691647f66a81241358fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads what was written by WriteAlignedBytesSafe.  <a href="#a2fcd3b86367691647f66a81241358fe7"></a><br/></td></tr>
<tr class="separator:a2fcd3b86367691647f66a81241358fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ada145cbde1fb34dc4187b33ca5b4f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a9ada145cbde1fb34dc4187b33ca5b4f6">ReadAlignedBytesSafeAlloc</a> (char **outByteArray, int &amp;inputLength, const unsigned int maxBytesToRead)</td></tr>
<tr class="memdesc:a9ada145cbde1fb34dc4187b33ca5b4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classRakNet_1_1BitStream.html#a2fcd3b86367691647f66a81241358fe7" title="Reads what was written by WriteAlignedBytesSafe.">ReadAlignedBytesSafe()</a> but allocates the memory for you using new, rather than assuming it is safe to write to.  <a href="#a9ada145cbde1fb34dc4187b33ca5b4f6"></a><br/></td></tr>
<tr class="separator:a9ada145cbde1fb34dc4187b33ca5b4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157d750a205462beb3b418ade252cf19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a157d750a205462beb3b418ade252cf19">AlignWriteToByteBoundary</a> (void)</td></tr>
<tr class="memdesc:a157d750a205462beb3b418ade252cf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align the next write and/or read to a byte boundary.  <a href="#a157d750a205462beb3b418ade252cf19"></a><br/></td></tr>
<tr class="separator:a157d750a205462beb3b418ade252cf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbbeb19cf6b7fbb5c170ae366d4be30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aadbbeb19cf6b7fbb5c170ae366d4be30">AlignReadToByteBoundary</a> (void)</td></tr>
<tr class="memdesc:aadbbeb19cf6b7fbb5c170ae366d4be30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align the next write and/or read to a byte boundary.  <a href="#aadbbeb19cf6b7fbb5c170ae366d4be30"></a><br/></td></tr>
<tr class="separator:aadbbeb19cf6b7fbb5c170ae366d4be30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386965784e4352212b047c1c3dcb51f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a386965784e4352212b047c1c3dcb51f3">ReadBits</a> (unsigned char *inOutByteArray, BitSize_t numberOfBitsToRead, const bool alignBitsToRight=true)</td></tr>
<tr class="memdesc:a386965784e4352212b047c1c3dcb51f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read <em>numberOfBitsToRead</em> bits to the output source.  <a href="#a386965784e4352212b047c1c3dcb51f3"></a><br/></td></tr>
<tr class="separator:a386965784e4352212b047c1c3dcb51f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad944a6707a90f1727bcc5ac8de2b58bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad944a6707a90f1727bcc5ac8de2b58bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad944a6707a90f1727bcc5ac8de2b58bd">Write0</a> (void)</td></tr>
<tr class="memdesc:ad944a6707a90f1727bcc5ac8de2b58bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 0. <br/></td></tr>
<tr class="separator:ad944a6707a90f1727bcc5ac8de2b58bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185c35c9ca1fc58057d9e94a025d3961"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a185c35c9ca1fc58057d9e94a025d3961"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a185c35c9ca1fc58057d9e94a025d3961">Write1</a> (void)</td></tr>
<tr class="memdesc:a185c35c9ca1fc58057d9e94a025d3961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 1. <br/></td></tr>
<tr class="separator:a185c35c9ca1fc58057d9e94a025d3961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bf969fc517f2e568ce02c4a859cc27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48bf969fc517f2e568ce02c4a859cc27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a48bf969fc517f2e568ce02c4a859cc27">ReadBit</a> (void)</td></tr>
<tr class="memdesc:a48bf969fc517f2e568ce02c4a859cc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 1 bit and returns true if that bit is 1 and false if it is 0. <br/></td></tr>
<tr class="separator:a48bf969fc517f2e568ce02c4a859cc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4d4693f8fa98c3fa757da57fcb0c5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c4d4693f8fa98c3fa757da57fcb0c5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a0c4d4693f8fa98c3fa757da57fcb0c5d">AssertCopyData</a> (void)</td></tr>
<tr class="memdesc:a0c4d4693f8fa98c3fa757da57fcb0c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we used the constructor version with copy data off, this *makes sure it is set to on and the data pointed to is copied. <br/></td></tr>
<tr class="separator:a0c4d4693f8fa98c3fa757da57fcb0c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6bd33c456e1593e002207bc3ec5c28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba6bd33c456e1593e002207bc3ec5c28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aba6bd33c456e1593e002207bc3ec5c28">SetNumberOfBitsAllocated</a> (const BitSize_t lengthInBits)</td></tr>
<tr class="memdesc:aba6bd33c456e1593e002207bc3ec5c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this if you pass a pointer copy to the constructor *(_copyData==false) and want to overallocate to prevent reallocation. <br/></td></tr>
<tr class="separator:aba6bd33c456e1593e002207bc3ec5c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee4d3114fcce22de87644241dcdd39b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ee4d3114fcce22de87644241dcdd39b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a8ee4d3114fcce22de87644241dcdd39b">AddBitsAndReallocate</a> (const BitSize_t numberOfBitsToWrite)</td></tr>
<tr class="memdesc:a8ee4d3114fcce22de87644241dcdd39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates (if necessary) in preparation of writing numberOfBitsToWrite. <br/></td></tr>
<tr class="separator:a8ee4d3114fcce22de87644241dcdd39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554b5dff8da17052d12ed620bb8cf53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac554b5dff8da17052d12ed620bb8cf53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ac554b5dff8da17052d12ed620bb8cf53">Read</a> (char *varString)</td></tr>
<tr class="memdesc:ac554b5dff8da17052d12ed620bb8cf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read strings, non reference. <br/></td></tr>
<tr class="separator:ac554b5dff8da17052d12ed620bb8cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1517a13993e3b19f84692db75d1c162f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1517a13993e3b19f84692db75d1c162f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1517a13993e3b19f84692db75d1c162f">PadWithZeroToByteLength</a> (unsigned int bytes)</td></tr>
<tr class="memdesc:a1517a13993e3b19f84692db75d1c162f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write zeros until the bitstream is filled up to <em>bytes</em>. <br/></td></tr>
<tr class="separator:a1517a13993e3b19f84692db75d1c162f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b52fab9bbf560e6e1f489fcb721606"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a66b52fab9bbf560e6e1f489fcb721606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a66b52fab9bbf560e6e1f489fcb721606">Write</a> (const bool &amp;inTemplateVar)</td></tr>
<tr class="memdesc:a66b52fab9bbf560e6e1f489fcb721606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a bool to a bitstream.  <a href="#a66b52fab9bbf560e6e1f489fcb721606"></a><br/></td></tr>
<tr class="separator:a66b52fab9bbf560e6e1f489fcb721606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e36831cf50b73139527f724520af97"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa0e36831cf50b73139527f724520af97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aa0e36831cf50b73139527f724520af97">Write</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;inTemplateVar)</td></tr>
<tr class="memdesc:aa0e36831cf50b73139527f724520af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a systemAddress to a bitstream.  <a href="#aa0e36831cf50b73139527f724520af97"></a><br/></td></tr>
<tr class="separator:aa0e36831cf50b73139527f724520af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c45b04dff683e04916b8da25de8154"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab0c45b04dff683e04916b8da25de8154"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ab0c45b04dff683e04916b8da25de8154">Write</a> (const <a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;inTemplateVar)</td></tr>
<tr class="memdesc:ab0c45b04dff683e04916b8da25de8154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a string to a bitstream.  <a href="#ab0c45b04dff683e04916b8da25de8154"></a><br/></td></tr>
<tr class="separator:ab0c45b04dff683e04916b8da25de8154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69701ef7d6efe0f69d61ff8287ccb78"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad69701ef7d6efe0f69d61ff8287ccb78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad69701ef7d6efe0f69d61ff8287ccb78">WriteDelta</a> (const bool &amp;currentValue, const bool &amp;lastValue)</td></tr>
<tr class="memdesc:ad69701ef7d6efe0f69d61ff8287ccb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a bool delta. Same thing as just calling Write.  <a href="#ad69701ef7d6efe0f69d61ff8287ccb78"></a><br/></td></tr>
<tr class="separator:ad69701ef7d6efe0f69d61ff8287ccb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f89758b7be3a989c530ebd296c3e78"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa9f89758b7be3a989c530ebd296c3e78"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa9f89758b7be3a989c530ebd296c3e78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aa9f89758b7be3a989c530ebd296c3e78">WriteCompressed</a> (const float &amp;inTemplateVar)</td></tr>
<tr class="memdesc:aa9f89758b7be3a989c530ebd296c3e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">For values between -1 and 1. <br/></td></tr>
<tr class="separator:aa9f89758b7be3a989c530ebd296c3e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ea1b0e57f1ce372927fbace20f3f88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a96ea1b0e57f1ce372927fbace20f3f88"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a96ea1b0e57f1ce372927fbace20f3f88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a96ea1b0e57f1ce372927fbace20f3f88">WriteCompressed</a> (const double &amp;inTemplateVar)</td></tr>
<tr class="memdesc:a96ea1b0e57f1ce372927fbace20f3f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">For values between -1 and 1. <br/></td></tr>
<tr class="separator:a96ea1b0e57f1ce372927fbace20f3f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177d488f81c3c30898ea8b9ef014f759"><td class="memTemplParams" colspan="2"><a class="anchor" id="a177d488f81c3c30898ea8b9ef014f759"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a177d488f81c3c30898ea8b9ef014f759"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a177d488f81c3c30898ea8b9ef014f759">WriteCompressed</a> (const <a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;inTemplateVar)</td></tr>
<tr class="memdesc:a177d488f81c3c30898ea8b9ef014f759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the string. <br/></td></tr>
<tr class="separator:a177d488f81c3c30898ea8b9ef014f759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5f7b8b48221334644d4f50ee6d5762"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8f5f7b8b48221334644d4f50ee6d5762"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a8f5f7b8b48221334644d4f50ee6d5762">WriteCompressedDelta</a> (const bool &amp;currentValue, const bool &amp;lastValue)</td></tr>
<tr class="memdesc:a8f5f7b8b48221334644d4f50ee6d5762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a bool delta. Same thing as just calling Write.  <a href="#a8f5f7b8b48221334644d4f50ee6d5762"></a><br/></td></tr>
<tr class="separator:a8f5f7b8b48221334644d4f50ee6d5762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf066d10aafd4e935dd1bbced77a1a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8cf066d10aafd4e935dd1bbced77a1a7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8cf066d10aafd4e935dd1bbced77a1a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a8cf066d10aafd4e935dd1bbced77a1a7">WriteCompressedDelta</a> (const bool &amp;currentValue)</td></tr>
<tr class="memdesc:a8cf066d10aafd4e935dd1bbced77a1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save as WriteCompressedDelta(bool currentValue, const templateType &amp;lastValue) when we have an unknown second bool. <br/></td></tr>
<tr class="separator:a8cf066d10aafd4e935dd1bbced77a1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93e4e7cc020377abccf312a0a35029c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa93e4e7cc020377abccf312a0a35029c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aa93e4e7cc020377abccf312a0a35029c">Read</a> (bool &amp;outTemplateVar)</td></tr>
<tr class="memdesc:aa93e4e7cc020377abccf312a0a35029c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bool from a bitstream.  <a href="#aa93e4e7cc020377abccf312a0a35029c"></a><br/></td></tr>
<tr class="separator:aa93e4e7cc020377abccf312a0a35029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8909d80334b1db974de6942e33a563"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a4e8909d80334b1db974de6942e33a563"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a4e8909d80334b1db974de6942e33a563">Read</a> (<a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;outTemplateVar)</td></tr>
<tr class="memdesc:a4e8909d80334b1db974de6942e33a563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a systemAddress from a bitstream.  <a href="#a4e8909d80334b1db974de6942e33a563"></a><br/></td></tr>
<tr class="separator:a4e8909d80334b1db974de6942e33a563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377a1aa3f331581e613f6a504ffdd284"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a377a1aa3f331581e613f6a504ffdd284"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a377a1aa3f331581e613f6a504ffdd284">ReadDelta</a> (bool &amp;outTemplateVar)</td></tr>
<tr class="memdesc:a377a1aa3f331581e613f6a504ffdd284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bool from a bitstream.  <a href="#a377a1aa3f331581e613f6a504ffdd284"></a><br/></td></tr>
<tr class="separator:a377a1aa3f331581e613f6a504ffdd284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9e41a93c48e6538d3ce3a6c7055144"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2d9e41a93c48e6538d3ce3a6c7055144"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2d9e41a93c48e6538d3ce3a6c7055144"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a2d9e41a93c48e6538d3ce3a6c7055144">ReadCompressed</a> (float &amp;outTemplateVar)</td></tr>
<tr class="memdesc:a2d9e41a93c48e6538d3ce3a6c7055144"><td class="mdescLeft">&#160;</td><td class="mdescRight">For values between -1 and 1. <br/></td></tr>
<tr class="separator:a2d9e41a93c48e6538d3ce3a6c7055144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258dffc96b125c78bb66b0de3ad40f04"><td class="memTemplParams" colspan="2"><a class="anchor" id="a258dffc96b125c78bb66b0de3ad40f04"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a258dffc96b125c78bb66b0de3ad40f04"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a258dffc96b125c78bb66b0de3ad40f04">ReadCompressed</a> (double &amp;outTemplateVar)</td></tr>
<tr class="memdesc:a258dffc96b125c78bb66b0de3ad40f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">For values between -1 and 1. <br/></td></tr>
<tr class="separator:a258dffc96b125c78bb66b0de3ad40f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eada178332c4b8067603dfde95dfc0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2eada178332c4b8067603dfde95dfc0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab2eada178332c4b8067603dfde95dfc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ab2eada178332c4b8067603dfde95dfc0">ReadCompressed</a> (<a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;outTemplateVar)</td></tr>
<tr class="memdesc:ab2eada178332c4b8067603dfde95dfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For strings. <br/></td></tr>
<tr class="separator:ab2eada178332c4b8067603dfde95dfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a446bd34af864078b1db95b151a54"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad83a446bd34af864078b1db95b151a54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ad83a446bd34af864078b1db95b151a54">ReadCompressedDelta</a> (bool &amp;outTemplateVar)</td></tr>
<tr class="memdesc:ad83a446bd34af864078b1db95b151a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bool from a bitstream.  <a href="#ad83a446bd34af864078b1db95b151a54"></a><br/></td></tr>
<tr class="separator:ad83a446bd34af864078b1db95b151a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afc678e70ac2082d65c1b103436ca6b6f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#afc678e70ac2082d65c1b103436ca6b6f">NumberOfLeadingZeroes</a> (uint8_t x)</td></tr>
<tr class="separator:afc678e70ac2082d65c1b103436ca6b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce179acbb0ca867dacd482013831a30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce179acbb0ca867dacd482013831a30"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a1ce179acbb0ca867dacd482013831a30">DoEndianSwap</a> (void)</td></tr>
<tr class="memdesc:a1ce179acbb0ca867dacd482013831a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">-&mdash; Member function template specialization declarations -&mdash; <br/></td></tr>
<tr class="separator:a1ce179acbb0ca867dacd482013831a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class allows you to write and read native types as a string of bits. <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> is used extensively throughout <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher that can be used f...">RakNet</a> and is designed to be used by users as well. </p>
<dl class="section see"><dt>See Also</dt><dd>BitStreamSample.txt </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a47b1c7ce200c4815bd2a42d454244bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RakNet::BitStream::BitStream </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>initialBytesToAllocate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the bitstream, with some number of bytes to immediately allocate. </p>
<p>There is no benefit to calling this, unless you know exactly how many bytes you need and it is greater than BITSTREAM_STACK_ALLOCATION_SIZE. In that case all it does is save you one or more realloc calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initialBytesToAllocate</td><td>the number of bytes to pre-allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04a200eaf5b379cad2e30d5de15a2c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RakNet::BitStream::BitStream </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>lengthInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_copyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a>, immediately setting the data it contains to a predefined pointer. </p>
<p>Set <em>_copyData</em> to true if you want to make an internal copy of the data you are passing. Set it to false to just save a pointer to the data. You shouldn't call Write functions with <em>_copyData</em> as false, as this will write to unallocated memory 99% of the time you will use this function to cast <a class="el" href="structRakNet_1_1Packet.html#a63e46b85c8ca156b205a124e54659614" title="The data from the sender.">Packet::data</a> to a bitstream for reading, in which case you should write something as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> bs(packet-&gt;data, packet-&gt;length, <span class="keyword">false</span>);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_data</td><td>An array of bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthInBytes</td><td>Size of the <em>_data</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_copyData</td><td>true or false to make a copy of <em>_data</em> or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aadbbeb19cf6b7fbb5c170ae366d4be30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::AlignReadToByteBoundary </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Align the next write and/or read to a byte boundary. </p>
<p>This can be used to 'waste' bits to byte align for efficiency reasons It can also be used to force coalesced bitstreams to start on byte boundaries so so WriteAlignedBits and ReadAlignedBits both calculate the same offset when aligning. </p>

</div>
</div>
<a class="anchor" id="a157d750a205462beb3b418ade252cf19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::AlignWriteToByteBoundary </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Align the next write and/or read to a byte boundary. </p>
<p>This can be used to 'waste' bits to byte align for efficiency reasons It can also be used to force coalesced bitstreams to start on byte boundaries so so WriteAlignedBits and ReadAlignedBits both calculate the same offset when aligning. </p>

</div>
</div>
<a class="anchor" id="a8471c4c11d6cc08bf713c8f8273d86b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BitSize_t RakNet::BitStream::CopyData </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a copy of the internal data for you <em>_data</em> will point to the stream. Partial bytes are left aligned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_data</td><td>The allocated copy of <a class="el" href="classRakNet_1_1BitStream.html#a2e201444796178e5074083b6d09bd221">GetData()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length in bits of the stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e201444796178e5074083b6d09bd221"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* RakNet::BitStream::GetData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the data that <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> is writing to / reading from. Partial bytes are left aligned. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal state </dd></dl>

</div>
</div>
<a class="anchor" id="a1952b3b3007b120fdd143f87311a98a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::IgnoreBits </td>
          <td>(</td>
          <td class="paramtype">const BitSize_t&#160;</td>
          <td class="paramname"><em>numberOfBits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore data we don't intend to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBits</td><td>The number of bits to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26310ba75436c24a1272e65da6a90a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::IgnoreBytes </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numberOfBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore data we don't intend to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBits</td><td>The number of bytes to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc678e70ac2082d65c1b103436ca6b6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int RakNet::BitStream::NumberOfLeadingZeroes </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of leading zeros for a number </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Number to test </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a865bd246780b10e2b9d7c1bc13044343"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read any integral type from a bitstream. </p>
<p>Read any integral type from a bitstream. Define __BITSTREAM_NATIVE_END if you need endian swapping.</p>
<p>Define __BITSTREAM_NATIVE_END if you need endian swapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a025f73d57a5ebe8fb6393eca5f3616df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *&#160;</td>
          <td class="paramname"><em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&#160;</td>
          <td class="paramname"><em>numberOfBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one bitstream to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBits</td><td>bits to read </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bitStream</td><td>the bitstream to read into from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a25b53ddc6f6bc9a1e0c01cb677a3c6d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numberOfBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an array or casted stream of byte. </p>
<p>The array is raw data. There is no automatic endian conversion with this function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The result byte array. It should be larger than <em>numberOfBytes</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBytes</td><td>The number of byte to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success false if there is some missing bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa93e4e7cc020377abccf312a0a35029c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bool from a bitstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e8909d80334b1db974de6942e33a563"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a systemAddress from a bitstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1543023e7a84ecbf58a777aa2071b444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadAlignedBytes </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numberOfBytesToRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bits, starting at the next aligned bits. </p>
<p>Note that the modulus 8 starting offset of the sequence must be the same as was used with WriteBits. This will be a problem with packet coalescence unless you byte align the coalesced packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutByteArray</td><td>The byte array larger than <em>numberOfBytesToRead</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBytesToRead</td><td>The number of byte to read from the internal state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is enough byte. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fcd3b86367691647f66a81241358fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadAlignedBytesSafe </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxBytesToRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads what was written by WriteAlignedBytesSafe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutByteArray</td><td>The data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxBytesToRead</td><td>Maximum number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ada145cbde1fb34dc4187b33ca5b4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadAlignedBytesSafeAlloc </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>outByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>maxBytesToRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classRakNet_1_1BitStream.html#a2fcd3b86367691647f66a81241358fe7" title="Reads what was written by WriteAlignedBytesSafe.">ReadAlignedBytesSafe()</a> but allocates the memory for you using new, rather than assuming it is safe to write to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outByteArray</td><td>outByteArray will be deleted if it is not a pointer to 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a386965784e4352212b047c1c3dcb51f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadBits </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&#160;</td>
          <td class="paramname"><em>numberOfBitsToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>alignBitsToRight</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read <em>numberOfBitsToRead</em> bits to the output source. </p>
<p>alignBitsToRight should be set to true to convert internal bitstream data to userdata. It should be false if you used WriteBits with rightAlignedBits false </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutByteArray</td><td>The resulting bits array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBitsToRead</td><td>The number of bits to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignBitsToRight</td><td>if true bits will be right aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is enough bits to read </dd></dl>

</div>
</div>
<a class="anchor" id="a620645af65289abfb244270261060df9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadBitsFromIntegerRange </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOutsideRange</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range Then read only those bits </p>
<dl class="section note"><dt>Note</dt><dd>A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that <em>minimum</em> and  are fixed values for a given line of code for the life of the program </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integer value to read, which should be between <em>minimum</em> and <em>maximum</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minimum</td><td>Minimum value of <em>value</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maximum</td><td>Maximum value of <em>value</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowOutsideRange</td><td>If true, all sends will take an extra bit, however value can deviate from outside <em>minimum</em> and <em>maximum</em>. If false, will assert if the value deviates. This should match the corresponding value passed to <a class="el" href="classRakNet_1_1BitStream.html#acc0d0bb96142a302385613d44e66558b" title="Write any integral type to a bitstream.">Write()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2ebc24f3cf193f77d7cd4c3e1eaf22f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadBitsFromIntegerRange </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>requiredBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOutsideRange</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredBits</td><td>Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab282a3cea68401414d8569f997a5367"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class serializationType , class sourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCasted </td>
          <td>(</td>
          <td class="paramtype">sourceType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one type serialized to another (smaller) type, to save bandwidth serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t Example: int num; ReadCasted&lt;uint8_t&gt;(num); would read 1 bytefrom the stream, and put the value in an integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc394f439d9112328f92e7b22d116e5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCompressed </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read any integral type from a bitstream. </p>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure.</dd></dl>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a099c2c8fb1b5321aacb5bded88a8f300"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCompressedDelta </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read any integral type from a bitstream. </p>
<p>If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. the current value will be updated. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte ReadCompressedDelta is only valid from a previous call to WriteDelta </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure.</dd></dl>
<p>If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. the current value will be updated. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte ReadCompressedDelta is only valid from a previous call to WriteDelta </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad83a446bd34af864078b1db95b151a54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCompressedDelta </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bool from a bitstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad19904647a86e54757a4a740d1275b00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadDelta </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read any integral type from a bitstream. </p>
<p>If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. ReadDelta is only valid from a previous call to WriteDelta </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure.</dd></dl>
<p>If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. ReadDelta is only valid from a previous call to WriteDelta </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a377a1aa3f331581e613f6a504ffdd284"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadDelta </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>outTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bool from a bitstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outTemplateVar</td><td>The value to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8275d390e2114d55449bb4ae2d01d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadFloat16 </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>outFloat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>floatMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>floatMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outFloat</td><td>The float to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floatMin</td><td>Predetermined minimum value of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floatMax</td><td>Predetermined maximum value of f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6ec569c23a95f8ee46ec36c4b8303da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadNormQuat </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>w </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa9b48a07801cb8628dd5523a275a917"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadNormVector </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes. </p>
<p>Will further compress y or z axis aligned vectors. Accurate to 1/32767.5. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a542c53992e9896cddb7a1bd96bce06ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadOrthMatrix </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m20</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m22</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an orthogonal matrix from a quaternion, reading 3 components of the quaternion in 2 bytes each and extrapolatig the 4th. </p>
<p>Use 6 bytes instead of 36 Lossy, although the result is renormalized </p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c0d350e53bc70d3d24def9b6bbf62ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadVector </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 3 floats or doubles, using 10 bytes, where those float or doubles comprise a vector. </p>
<p>Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="adf95af1e57ce9a5386ab6a620ffd593b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Serialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>inOutTemplateVar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize any integral type to/from a bitstream. </p>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutTemplateVar</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2e3ec310191a69b9bba227a72e65537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Serialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numberOfBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize an array or casted stream or raw data. This does NOT do endian swapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutByteArray</td><td>a byte buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBytes</td><td>the size of <em>input</em> in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a25c0f31d16b211a2aa7cdb3ec594cbf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeBits </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitSize_t&#160;</td>
          <td class="paramname"><em>numberOfBitsToSerialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>rightAlignedBits</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize numberToSerialize bits to/from the input. </p>
<p>Right aligned data means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation) You would set this to true when writing user data, and false when copying bitstream data, such as writing one bitstream to another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutByteArray</td><td>The data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBitsToSerialize</td><td>The number of bits to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightAlignedBits</td><td>if true data will be right aligned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cfb0266bf435e0bba8b221f089a4aec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeBitsFromIntegerRange </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOutsideRange</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range Then serialize only those bits </p>
<dl class="section note"><dt>Note</dt><dd>A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that <em>minimum</em> and  are fixed values for a given line of code for the life of the program </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integer value to write, which should be between <em>minimum</em> and <em>maximum</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minimum</td><td>Minimum value of <em>value</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maximum</td><td>Maximum value of <em>value</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowOutsideRange</td><td>If true, all sends will take an extra bit, however value can deviate from outside <em>minimum</em> and <em>maximum</em>. If false, will assert if the value deviates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91e811bf0d8447faedc96261920944cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeBitsFromIntegerRange </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>requiredBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOutsideRange</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredBits</td><td>Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3615fc88c34f910085e0f94a6231926b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class serializationType , class sourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCasted </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sourceType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize one type casted to another (smaller) type, to save bandwidth serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t Example: int num=53; SerializeCasted&lt;uint8_t&gt;(true, num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to serialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fdf11345fb4e998d411b87426648a36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCompressed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>inOutTemplateVar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize any integral type to/from a bitstream. </p>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutTemplateVar</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a1991ab41173693f8e9c0e78c9ad2a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCompressedDelta </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>inOutCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>lastValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize any integral type to/from a bitstream. </p>
<p>If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutCurrentValue</td><td>The current value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastValue</td><td>The last value to compare against. Only used if <em>writeToBitstream</em> is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1ca9bf6bb61905e43003097d7af79fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCompressedDelta </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>inOutTemplateVar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save as SerializeCompressedDelta(templateType &amp;currentValue, const templateType &amp;lastValue) when we have an unknown second parameter. </p>
<dl class="section return"><dt>Returns</dt><dd>true on data read. False on insufficient data in bitstream </dd></dl>

</div>
</div>
<a class="anchor" id="a6aab79184deb91907b7bc8934ca45bc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeDelta </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>inOutCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>lastValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize any integral type to/from a bitstream. </p>
<p>If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutCurrentValue</td><td>The current value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastValue</td><td>The last value to compare against. Only used if <em>writeToBitstream</em> is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1cc6838ab5b4477ac7a4021bb1356c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeDelta </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>inOutCurrentValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional version of SerializeDelta when you don't know what the last value is, or there is no last value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutCurrentValue</td><td>The current value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a1aebab1c543acd21742f380c95255365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeFloat16 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>inOutFloat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>floatMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>floatMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inOutFloat</td><td>The float to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floatMin</td><td>Predetermined minimum value of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floatMax</td><td>Predetermined maximum value of f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03953490ce2c0fbc5cebb67fdebdb75d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeNormQuat </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>w </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e357618f04ee5166fe74a9738a28b82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeNormVector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes. </p>
<p>Will further compress y or z axis aligned vectors. Accurate to 1/32767.5. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ad45063562f20be6154c17bef523ac846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeOrthMatrix </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m20</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>m22</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each. </p>
<p>Use 6 bytes instead of 36 Lossy, although the result is renormalized </p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad39a138bf295277ed6f804d6d2d5d9fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeVector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bidirectional serialize/deserialize a vector, using 10 bytes instead of 12. </p>
<p>Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writeToBitstream</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div>
<a class="anchor" id="aa56ebc6a1381369ddc2a6d7821512d7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::SetWriteOffset </td>
          <td>(</td>
          <td class="paramtype">const BitSize_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the write pointer to a position on the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>the offset from the start of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>Dangerous if you don't know what you are doing! For efficiency reasons you can only write mid-stream if your data is byte aligned. </p>

</div>
</div>
<a class="anchor" id="acc0d0bb96142a302385613d44e66558b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>inTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write any integral type to a bitstream. </p>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inTemplateVar</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c6e2624a5960f9ac40d4072a6e607e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inputByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numberOfBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an array or casted stream or raw data. This does NOT do endian swapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputByteArray</td><td>a byte buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBytes</td><td>the size of <em>input</em> in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26624b5669df1c38f6dd6dabf4c1b769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *&#160;</td>
          <td class="paramname"><em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&#160;</td>
          <td class="paramname"><em>numberOfBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one bitstream to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBits</td><td>bits to write </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bitStream</td><td>the bitstream to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66b52fab9bbf560e6e1f489fcb721606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>inTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a bool to a bitstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inTemplateVar</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0e36831cf50b73139527f724520af97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>inTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a systemAddress to a bitstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inTemplateVar</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0c45b04dff683e04916b8da25de8154"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;&#160;</td>
          <td class="paramname"><em>inTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a string to a bitstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcd8b1c73408fc1e4e8088ca858c0f7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteAlignedBytes </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>inByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numberOfBytesToWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align the bitstream to the byte boundary and then write the specified number of bits. </p>
<p>This is faster than WriteBits but wastes the bits to do the alignment and requires you to call ReadAlignedBits at the corresponding read position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inByteArray</td><td>The data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBytesToWrite</td><td>The size of input. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ae285a7aaba6f50b5ce8e5bf4163639"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteAlignedBytesSafe </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>maxBytesToWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inByteArray</td><td>The data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputLength</td><td>The size of input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxBytesToWrite</td><td>Max bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6357c08afed23e2e857c418cbbb3a29a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteBits </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>inByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&#160;</td>
          <td class="paramname"><em>numberOfBitsToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>rightAlignedBits</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write numberToWrite bits from the input source. </p>
<p>Right aligned data means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation) You would set this to true when writing user data, and false when copying bitstream data, such as writing one bitstream to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inByteArray</td><td>The data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfBitsToWrite</td><td>The number of bits to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightAlignedBits</td><td>if true data will be right aligned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e9345107dfe25bfe800aa17826a77b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteBitsFromIntegerRange </td>
          <td>(</td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOutsideRange</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range Then write only those bits </p>
<dl class="section note"><dt>Note</dt><dd>A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that <em>minimum</em> and  are fixed values for a given line of code for the life of the program </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integer value to write, which should be between <em>minimum</em> and <em>maximum</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minimum</td><td>Minimum value of <em>value</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maximum</td><td>Maximum value of <em>value</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowOutsideRange</td><td>If true, all sends will take an extra bit, however value can deviate from outside <em>minimum</em> and <em>maximum</em>. If false, will assert if the value deviates. This should match the corresponding value passed to <a class="el" href="classRakNet_1_1BitStream.html#a865bd246780b10e2b9d7c1bc13044343" title="Read any integral type from a bitstream.">Read()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f0064de4e5e34478bdf43623c8d41a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteBitsFromIntegerRange </td>
          <td>(</td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>requiredBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOutsideRange</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">requiredBits</td><td>Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13ecfa7830db77b09a1d121bffdccb67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class destinationType , class sourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCasted </td>
          <td>(</td>
          <td class="paramtype">const sourceType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write one type serialized as another (smaller) type, to save bandwidth serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t Example: int num=53; WriteCasted&lt;uint8_t&gt;(num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac32700a1c6f26d15890470dba1532ef4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCompressed </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>inTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write any integral type to a bitstream. </p>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inTemplateVar</td><td>The value to write</td></tr>
  </table>
  </dd>
</dl>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inTemplateVar</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f8aab299cf0eb021802ed8671844948"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCompressedDelta </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>lastValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write any integral type to a bitstream. </p>
<p>If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentValue</td><td>The current value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastValue</td><td>The last value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f5f7b8b48221334644d4f50ee6d5762"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCompressedDelta </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>lastValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a bool delta. Same thing as just calling Write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentValue</td><td>The current value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastValue</td><td>The last value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd8613fe1f3d998a125fd2962c905e67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteDelta </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>lastValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write any integral type to a bitstream. </p>
<p>If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentValue</td><td>The current value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastValue</td><td>The last value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09461811793e5719e574d47bc513ac8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteDelta </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&#160;</td>
          <td class="paramname"><em>currentValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteDelta when you don't know what the last value is, or there is no last value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentValue</td><td>The current value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad69701ef7d6efe0f69d61ff8287ccb78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteDelta </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>lastValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a bool delta. Same thing as just calling Write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentValue</td><td>The current value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastValue</td><td>The last value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b37ff9ba34ce6f98c8521710ba51366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteFloat16 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>floatMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>floatMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The float to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floatMin</td><td>Predetermined minimum value of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floatMax</td><td>Predetermined maximum value of f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb96f0dce8b1a864799d02211cf34d8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteNormQuat </td>
          <td>(</td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>w </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac37adc6bd171459103131d788fdebf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteNormVector </td>
          <td>(</td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes. </p>
<p>Will further compress y or z axis aligned vectors. Accurate to 1/32767.5. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb06e701aa336f41c314b88ae27c60bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteOrthMatrix </td>
          <td>(</td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m20</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>m22</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each. </p>
<p>Use 6 bytes instead of 36 Lossy, although the result is renormalized </p>

</div>
</div>
<a class="anchor" id="a2aa6ce96e75cf8339c29d7101a5bdb3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WritePtr </td>
          <td>(</td>
          <td class="paramtype">templateType *&#160;</td>
          <td class="paramname"><em>inTemplateVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the dereferenced pointer to any integral type to a bitstream. </p>
<p>Undefine __BITSTREAM_NATIVE_END if you need endian swapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inTemplateVar</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ffa67542bbe1e407a565652becb408f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteVector </td>
          <td>(</td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a vector, using 10 bytes instead of 12. </p>
<p>Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/temp/RakNet_PC/Source/<a class="el" href="BitStream_8h.html">BitStream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 2 2014 20:10:28 for RakNet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
