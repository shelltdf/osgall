[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:prepared_statements Prepared statements]

This section covers using [mysqllink sql-prepared-statements.html
server-side prepared statements]. You should use them whenever a query
contains parameters not known at compile-time.

[heading Preparing a statement]

To prepare a statement, call [refmem connection prepare_statement]
or [refmem connection async_prepare_statement], passing your statement
as a string. This yields a [reflink statement] object, which is templated
on the `Stream` type:

```
    // Table setup
    resultset result;
    conn.query(R"%(
        CREATE TEMPORARY TABLE products (
            id INT PRIMARY KEY AUTO_INCREMENT,
            description VARCHAR(256),
            price INT NOT NULL,
            show_in_store TINYINT
        )
    )%", result);

    // Prepare a statement to insert into this table
    tcp_ssl_statement stmt;
    conn.prepare_statement("INSERT INTO products (description, price, show_in_store) VALUES (?, ?, ?)", stmt);
```

The question mark characters (`?`) represent parameters 
(as described [mysqllink prepare.html here]).
When you execute the statement (next section), you
provide values for each of the parameters you declared, and the server
will use these values to run the statement.

[heading Executing a statement]

To execute a statement, use any of the following functions:

* [refmem statement execute] or [refmem statement async_execute], which execute the statement and
  read the generated results.
* [refmem statement start_execution] and [refmem statement async_start_execution], which initiate a
  statement execution as a multi-function operation.

For example:

```
    // description, price and show_in_store are not trusted, since they may
    // have been read from a file or an HTTP endpoint
    void insert_product(
        tcp_ssl_statement& stmt,
        string_view description,
        int price,
        bool show_in_store
    )
    {
        resultset result;
        stmt.execute(std::make_tuple(description, price, int(show_in_store)), result);
    }
```

Some observations:

* You must pass in [*exactly as many parameters
  as the statement has]. Failing to do so will result in an error.
* You don't need to sanitize the parameters anyhow. The server takes care of it.
* Actual parameters are matched to `?` placeholders by order. 
* Parameters are passed as a `std::tuple`. You can pass in built-in integers,
  `float`, `double`, [reflink date], [reflink datetime], [reflink time],
  [reflink field_view] and [reflink field] objects as parameters.
* `show_in_store` is passed as an `int` to `execute()`, but is defined as a `TINYINT`
  (1 byte integer) in the table. As long as the passed integer is in range, MySQL
  will perform the required conversions. Otherwise, `execute()` will fail with an error
  (no undefined behavior is invoked).

You can also pass [reflink field_view]s and [reflink field]s as parameters. This is handy
to insert `NULL` values:

```
    // description, price and show_in_store are not trusted, since they may
    // have been read from a file or an HTTP endpoint
    void insert_product(
        tcp_ssl_statement& stmt,
        std::optional<string_view> description,
        int price,
        bool show_in_store
    )
    {
        // if description has a value, description_param will have kind() == field_kind::string
        // and will point to it. Otherwise, description_param.kind() == field_kind::null
        auto description_param = description ? field_view(*description) : field_view();

        // Execute the insert
        resultset result;
        stmt.execute(std::make_tuple(description_param, price, int(show_in_store)), result);
    }
```

For a full reference on the types you can pass as parameters when
executing a statement, see [link mysql.fields.cpp_to_mysql this section].

[heading Closing a statement]

Prepared statements are created server-side, and thus consume server resources. If you don't need a 
[reflink statement] anymore, you can call [refmem statement close] or
[refmem statement async_close] to instruct the server to deallocate it.

Prepared statements are managed by the server on a per-connection basis. Once you close your connection
with the server, all prepared statements you have created using this connection will be automatically
deallocated.

If you are creating your prepared statements at the beginning
of your program and keeping them alive until the connection
is closed, then there is no need to call [refmem
statement close], as closing the connection will do the cleanup
for you. If you are creating and destroying prepared statements
dynamically, then it is advised to use [refmem
statement close] to prevent excessive resource usage in the server.

Finally, note that [reflink statement]'s destructor
does not perform any server-side deallocation of the statement.
This is because closing a statement involves a network
operation that may block your code or fail.

[endsect]
