[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]


[section:fields Fields]
[nochunk]

This section delves deeper on how to use [reflink field] and [reflink field_view]
and its underlying types. Please make sure you've read [link mysql.overview.fields this section]
before going on.

[section field_view vs field]

This library implements two types representing the concept of a field: [reflink field_view], which is non-owning,
and [reflink field], which is owning. The relationship between them is similar to the one between
`std::string_view` and `std::string`.

For efficiency reasons, all library functions return `field_view`s. For example:

```
    resultset result;
    conn.query("SELECT 'Hello world!'", result);
    field_view fv = result.rows().at(0).at(0); // fv doesn't own its memory; if result goes out of scope, fv becomes invalid
    string_view sv = fv.as_string(); // sv also points into result; if result goes out of scope, sv becomes invalid
```

When dealing with scalars (anything that is neither a string nor a blob), `field_view`'s accessors make
a copy of the scalar:

```
    resultset result;
    conn.query("SELECT 42", result);
    field_view fv = result.rows().at(0).at(0); // fv doesn't own its memory; if result goes out of scope, fv becomes invalid
    std::int64_t intv = fv.as_int64(); // intv is valid even after result goes out of scope
```

`field_view`s are cheap to create and to copy, as they are small objects and don't perform
any memory allocations. They are also immutable. On the other hand, `field`s may be more
expensive to create and copy, as they may perform memory allocations.

You may create a `field` from a `field_view`, taking ownership of its contents:

```
    resultset result;
    conn.query("SELECT 'Hello world!'", result);
    field_view fv = result.rows().at(0).at(0); // fv doesn't own its memory; if result goes out of scope, fv becomes invalid
    field f (fv); // f takes ownership of fv's contents. f is valid even after result goes out of scope
```

`field` and `field_view` use the same underlying types for scalars. For strings and blobs,
`field` uses the owning types `std::string` and [reflink blob], while `field_view` uses the
reference types [reflink string_view] and [reflink blob_view].

`field` accessors return references, which allow you to mutate the underlying object:

```
    field f ("my_string"); // constructs a field that owns the string "my_string"
    std::string& s = f.as_string(); // s points into f's storage
    s.push_back('2'); // f now holds "my_string2"
```

You can also mutate a `field` using `emplace_xxx`:

```
    field f ("my_string"); // constructs a field that owns the string "my_string"
    f.emplace_int64(42); // destroys "my_string" and stores the value 42 as an int64
```

Or using the assignment operator:

```
    field f ("my_string"); // constructs a field that owns the string "my_string"
    f = 42; // equivalent to f.emplace_int64(42)
```

[endsect]

[section Arithmetic types]

This library uses `std::int64_t` to represent all MySQL signed integers (`TINYINT`, `SMALLINT`, `MEDIUMINT`...).
Similarly, unsigned integers use `std::uint64_t`, 32-bit floats use `float` and 64-bit doubles
use `double`.

[endsect]

[section String types]

String types (`CHAR`, `VARCHAR`, `TEXT`, `SET`...) are represented as string fields, which
translates into [ref string_view] for `field_view` and `std::string` for `field`.

This library performs no character set conversion on strings. All strings are provided
as the server sends them. If you've issued a `"SET NAMES <charset-name>"` statement,
strings will be encoded according to `<charset-name>`. For details, see [link mysql.charsets this section].

The type `DECIMAL` is also provided as a string, to avoid losing precision.

[endsect]

[section Blob types]

The types `BINARY`, `VARBINARY` and `BLOB` (of any size) are represented as blob fields,
which are similar to string fields, but represent binary data instead of characters.
The following types are used:

* [reflink blob_view] is used by `field_view`. It's an alias for [@boost:/doc/html/core/span.html `boost::span<const unsigned char>`]
  (a C++11 backport of `std::span`).
* [reflink blob] is used by `field`. It's an alias for `std::vector<unsigned char>`.

If MySQL adds any other type that this library doesn't understand, it is also represented as a blob.

[endsect]

[section The DATE type]

MySQL __DATE__ is represented as [reflink date] in C++. `date` holds the year, month and day components of a date.
It is a type close to the protocol, rather than a vocabulary type. The main reason for using `date` instead
of a `std::chrono::time_point` type is that, under certain configurations, MySQL allows storing invalid
dates, such as `2020-00-01`. These are not representable as a `std::chrono::time_point`.

Unless dealing with these special values, we recommend converting `date`s to a `time_point` before using it.
The member type [refmem date time_point_type] is a system-clock `time_point` that can represent the entire
MySQL `DATE` range without problems. You can use [refmem date as_time_point] to perform the cast:

```
    date d (2020, 2, 19); // d holds "2020-02-19"
    date::time_point_type tp = d.as_time_point(); // now use tp normally
```

If the date is not valid, `as_time_point` will throw an exception.

You can query whether a `date` contains a valid date or not using [refmem date valid]:

```
    date d1 (2020, 2, 19); // regular date
    bool v1 = d1.valid();  // true
    date d2 (2020, 0, 19); // invalid date
    bool v2 = d1.valid();  // false
```

You can combine it with [refmem date get_time_point], which performs an unchecked
conversion:

```
    date d = /* obtain a date somehow */;
    if (d.valid())
    {
        // Same as as_time_point, but doesn't check for validity
        // Caution: if d is not valid, this will result in undefined behavior
        date::time_point_type tp = d.get_time_point();
    }
    else
    {
        // the date is invalid
    }
```

You can also construct a `date` from a `time_point`. If the `time_point` is
out of range, an exception is thrown.

[endsect]

[section The DATETIME and TIMESTAMP types]

Both types are represented as [reflink datetime] in C++. `datetime` represents a broken time point,
having year, month, day, hour, minute, second and microseconds.

MySQL also accepts invalid datetimes (like `2020-00-10 10:20:59.000000`). The same considerations for
`date` apply also to `datetime`:

```
    datetime dt1 (2020, 10, 11, 10, 20, 59, 123456); // regular datetime 2020-10-11 10:20:59.123456
    bool v1 = dt1.valid(); // true
    datetime dt2 (2020, 0, 11, 10, 20, 59); // invalid datetime 2020-00-10 10:20:59.000000
    bool v2 = dt1.valid(); // false

    datetime::time_point_type tp = dt1.as_time_point(); // convert to time_point
```

The `datetime` object doesn't carry any time zone information with it. The time zone semantics
depend on the actual MySQL type:

* __DATETIME__ is a "naive" time point object. It represents a time point without any time zone
  information at all. It is up to the user to interpret which time zone the object is in.
* When a __TIMESTAMP__ object is inserted, it is interpreted  to be in the connection's local time zone,
  as given by the __time_zone__ variable, and converted to UTC for storage. When retrieved, they are converted back
  to the time zone indicated by __time_zone__. The retrieved value of a `TIMESTAMP`
  field is thus a time point in some local time zone, dictated by the current
  __time_zone__ variable. As this variable can be changed programmatically, without
  the client knowing it, we represent `TIMESTAMP`'s using the `datetime` object, which doesn't include time zone information.

When working with `TIMESTAMP` values, we recommend setting the __time_zone__ to a known value. For example: 

```
    tcp_ssl_resultset result;
    conn.query("SET SESSION time_zone = UTC", result);
    // All TIMESTAMP values inserted or retrieved after this point will use UTC
```

[endsect]

[section The TIME type]

The __TIME__ type is a signed duration with a resolution of one microsecond.
It is represented using the [reflink time] type, an alias for a
`std::chrono::duration` specialization with microseconds as period.

[endsect]

[section Field accessors]

The following table summarizes the available accesors for `field_view` and `field`:

[template table_field_accessor[mem][refmem field [mem]][br][refmem field_view [mem]]]

[table
    [
        [`field_kind`]
        [C++ type]
        [MySQL types]
        [`is` accessor]
        [`as` accessor]
        [`get` accessor]
        [`emplace` mutator]
    ]
    [
        [`int64`]
        [`std::int64_t`]
        [Signed __TINYINT__, __SMALLINT__, __MEDIUMINT__, __INT__, __BIGINT__]
        [[table_field_accessor is_int64]]
        [[table_field_accessor as_int64]]
        [[table_field_accessor get_int64]]
        [[refmem field emplace_int64]]
    ]
    [
        [`uint64`]
        [`std::uint64_t`]
        [Unsigned __TINYINT__, __SMALLINT__, __MEDIUMINT__, __INT__, __BIGINT__, __YEAR__, __BIT__]
        [[table_field_accessor is_uint64]]
        [[table_field_accessor as_uint64]]
        [[table_field_accessor get_uint64]]
        [[refmem field emplace_uint64]]
    ]
    [
        [`string`]
        [
            [reflink string_view] for `field_view`
            
            `std::string` for `field`
        ]
        [
            __CHAR__, __VARCHAR__, __TEXT__ (all sizes), __ENUM__, __SET__, __DECIMAL__, __NUMERIC__
        ]
        [[table_field_accessor is_string]]
        [[table_field_accessor as_string]]
        [[table_field_accessor get_string]]
        [[refmem field emplace_string]]
    ]
    [
        [`blob`]
        [
            [reflink blob_view] for `field_view`
            
            [reflink blob] for `field`
        ]
        [
            __BINARY__, __VARBINARY__,  __BLOB__  (all sizes), __GEOMETRY__
        ]
        [[table_field_accessor is_blob]]
        [[table_field_accessor as_blob]]
        [[table_field_accessor get_blob]]
        [[refmem field emplace_blob]]
    ]
    [
        [`float_`]
        [`float`]
        [__FLOAT__]
        [[table_field_accessor is_float]]
        [[table_field_accessor as_float]]
        [[table_field_accessor get_float]]
        [[refmem field emplace_float]]
    ]
    [
        [`double_`]
        [`double`]
        [__DOUBLE__]
        [[table_field_accessor is_double]]
        [[table_field_accessor as_double]]
        [[table_field_accessor get_double]]
        [[refmem field emplace_double]]
    ]
    [
        [`date`]
        [[reflink date]]
        [__DATE__]
        [[table_field_accessor is_date]]
        [[table_field_accessor as_date]]
        [[table_field_accessor get_date]]
        [[refmem field emplace_date]]
    ]
    [
        [`datetime`]
        [[reflink datetime]]
        [__DATETIME__, __TIMESTAMP__]
        [[table_field_accessor is_datetime]]
        [[table_field_accessor as_datetime]]
        [[table_field_accessor get_datetime]]
        [[refmem field emplace_datetime]]
    ]
    [
        [`time`]
        [[reflink time]]
        [__TIME__]
        [[table_field_accessor is_time]]
        [[table_field_accessor as_time]]
        [[table_field_accessor get_time]]
        [[refmem field emplace_time]]
    ]
    [
        [`null`]
        []
        [Any of the above, when they're `NULL`]
        [[table_field_accessor is_null]]
        []
        []
        [[refmem field emplace_null]]
    ]
]

[endsect]

[section MySQL to C++ type mappings]

The following table reflects mapping from database types to C++ types.
The range column shows the range of values that MySQL admits for that type. This library
guarantees that any field retrieved from the database honors that range. The `column_type`
column shows what [refmem metadata type] would return for a column of that type. Additional
considerations are listed below.

[table
    [
        [MySQL type]
        [`field_kind`]
        [C++ type]
        [Range]
        [`column_type`]
        [Considerations]
    ]
    [
        [__TINYINT__, signed]
        [`int64`]
        [`std::int64_t`]
        [`-0x80` to `0x7f`]
        [`tinyint`]
        [1 byte integer]
    ]
    [
        [__TINYINT__, unsigned]
        [`uint64`]
        [`std::uint64_t`]
        [`0` to `0xff`]
        [`tinyint`]
        [1 byte integer]
    ]
    [
        [__SMALLINT__, signed]
        [`int64`]
        [`std::int64_t`]
        [`-0x8000` to `0x7fff`]
        [`smallint`]
        [2 byte integer]
    ]
    [
        [__SMALLINT__, unsigned]
        [`uint64`]
        [`std::uint64_t`]
        [`0` to `0xffff`]
        [`smallint`]
        [2 byte integer]
    ]
    [
        [__MEDIUMINT__, signed]
        [`int64`]
        [`std::int64_t`]
        [`-0x800000` to `0x7fffff`]
        [`mediumint`]
        [3 byte integer]
    ]
    [
        [__MEDIUMINT__, unsigned]
        [`uint64`]
        [`std::uint64_t`]
        [`0` to `0xffffff`]
        [`mediumint`]
        [3 byte integer]
    ]
    [
        [__INT__, signed]
        [`int64`]
        [`std::int64_t`]
        [`-0x80000000` to `0x7fffffff`]
        [`int_`]
        [4 byte integer]
    ]
    [
        [__INT__, unsigned]
        [`uint64`]
        [`std::uint64_t`]
        [`0` to `0xffffffff`]
        [`int_`]
        [4 byte integer]
    ]
    [
        [__BIGINT__, signed]
        [`int64`]
        [`std::int64_t`]
        [`-0x8000000000000000` to `0x7fffffffffffffff`]
        [`bigint`]
        [8 byte integer]
    ]
    [
        [__BIGINT__, unsigned]
        [`uint64`]
        [`std::uint64_t`]
        [`0` and `0xffffffffffffffff`]
        [`bigint`]
        [8 byte integer]
    ]
    [
        [__YEAR__]
        [`uint64`]
        [`std::uint64_t`]
        [\[`1901`, `2155`\], plus zero]
        [`year`]
        [
            1 byte integer type used to represent years

            Zero is often employed to represent invalid year values. We represent zero year here as a numeric 0.
        ]
    ]
    [
        [__BIT__]
        [`uint64`]
        [`std::uint64_t`]
        [Depends on the bitset width. Max `0` to `0xffffffffffffffff`.]
        [`bit`]
        [
            A bitset between 1 and 64 bits wide.
        ]
    ]
    [
        [__FLOAT__]
        [`float_`]
        [`float`]
        [IEEE 754 `float` range]
        [`float_`]
        [
            4 byte floating point type
        ]
    ]
    [
        [__DOUBLE__]
        [`double_`]
        [`double`]
        [IEEE 754 `double` range]
        [`double_`]
        [
            8 byte floating point type
        ]
    ]
    [
        [__DATE__]
        [`date`]
        [[reflink date]]
        [
            \[[reflink min_date], [reflink max_date]\] (some MySQL implementations may allow a narrower range),
            plus invalid and zero dates (see __allow_invalid_dates__ and  __strict_sql__).
        ]
        [`date`]
        []
    ]
    [
        [__DATETIME__]
        [`datetime`]
        [[reflink datetime]]
        [
            \[[reflink min_datetime], [reflink max_datetime]\] (some MySQL implementations may allow a narrower range),
            plus invalid and zero datetimes (see __allow_invalid_dates__ and  __strict_sql__).
        ]
        [`datetime`]
        [
            Time point type without time zone, with a resolution of one microsecond.
        ]
    ]
    [
        [__TIMESTAMP__]
        [`datetime`]
        [[reflink datetime]]
        [
            \[[reflink min_datetime], [reflink max_datetime]\] (the actual MySQL supported range is usually
            narrower, but we don't enforce it in the client), plus zero timestamps (see __strict_sql__).
        ]
        [`timestamp`]
        [
            Time point type with a resolution of one microsecond.
        ]
    ]
    [
        [__TIME__]
        [`time`]
        [[reflink time]]
        [
            \[[reflink min_time], [reflink max_time]\]
        ]
        [`time`]
        [
            Signed time duration, with a resolution of one microsecond.
        ]
    ]
    [
        [__CHAR__]
        [`string`]
        [[reflink string_view] or `std::string`]
        []
        [`char_`]
        [
            Fixed-size character string.
        ]
    ]
    [
        [__VARCHAR__]
        [`string`]
        [[reflink string_view] or `std::string`]
        []
        [`varchar`]
        [
            Variable size character string with a maximum size.
        ]
    ]
    [
        [__TEXT__ (all sizes)]
        [`string`]
        [[reflink string_view] or `std::string`]
        []
        [`text`]
        [
            Variable size character string.
        ]
    ]
    [
        [__ENUM__]
        [`string`]
        [[reflink string_view] or `std::string`]
        []
        [`enum_`]
        [
            Character string with a fixed set of possible values (only one possible).
        ]
    ]
    [
        [__SET__]
        [`string`]
        [[reflink string_view] or `std::string`]
        []
        [`set`]
        [
            Character string with a fixed set of possible values (many possible).
        ]
    ]
    [
        [__DECIMAL__/__NUMERIC__]
        [`string`]
        [[reflink string_view] or `std::string`]
        [Depends on the column definition]
        [`decimal`]
        [
            A fixed precision numeric value. In this case, the string will contain
            the textual representation of the number (e.g. the string `"20.52"` for `20.52`).
        ]
    ]
    [
        [__BINARY__]
        [`blob`]
        [[reflink blob_view] or [reflink blob]]
        []
        [`binary`]
        [
            Fixed-size blob.
        ]
    ]
    [
        [__VARBINARY__]
        [`blob`]
        [[reflink blob_view] or [reflink blob]]
        []
        [`varbinary`]
        [
            Variable size blob with a maximum size.
        ]
    ]
    [
        [__BLOB__ (all sizes)]
        [`blob`]
        [[reflink blob_view] or [reflink blob]]
        []
        [`blob`]
        [
            Variable size blob.
        ]
    ]
    [
        [__GEOMETRY__]
        [`blob`]
        [[reflink blob_view] or [reflink blob]]
        []
        [`geometry`]
        [
            Any of the spatial data types. The string contains the binary representation of the geometry type.
        ]
    ]
]

[endsect]


[section:cpp_to_mysql C++ to MySQL type mapping reference]

This section shows how a parameter `v` in a expression `stmt.execute(std::make_tuple(v), result)`
is interpreted by MySQL, depeding on `v`'s type:

[table
    [
        [C++ type]
        [MySQL type]
        [Compatible with...]
    ]
    [
        [`signed char`, `short`, `int`, `long`, `long long`]
        [`BIGINT`]
        [Signed `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`]
    ]
    [
        [`unsigned char`, `unsigned short`, `unsigned int`, `unsigned long`, `unsigned long long`]
        [`UNSIGNED BIGINT`]
        [Unsigned `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`, `YEAR`, `BIT`]
    ]
    [
        [`std::string`, [reflink string_view], `std::string_view`, `const char*`]
        [`VARCHAR`]
        [`CHAR`, `VARCHAR`, `TEXT` (all sizes), `ENUM`, `SET`, `DECIMAL`, `NUMERIC`]
    ]
    [
        [[reflink blob], [reflink blob_view]]
        [`BLOB`]
        [`BINARY`, `VARBINARY`, `BLOB` (all sizes), `GEOMETRY`]
    ]
    [
        [`float`]
        [`FLOAT`]
        [`FLOAT`]
    ]
    [
        [`double`]
        [`DOUBLE`]
        [`DOUBLE`]
    ]
    [
        [[reflink date]]
        [`DATE`]
        [`DATE`]
    ]
    [
        [[reflink datetime]]
        [`DATETIME`]
        [`DATETIME`, `TIMESTAMP`]
    ]
    [
        [[reflink time]]
        [`TIME`]
        [`TIME`]
    ]
    [
        [`std::nullptr_t`]
        [`NULL`]
        [Any of the other types. Used to insert `NULL`s, for example.]
    ]
    [
        [[reflink field_view]]
        [Depends on the actual type stored by the field]
        []
    ]
    [
        [[reflink field]]
        [Depends on the actual type stored by the field]
        []
    ]
]

[endsect]

[endsect]
