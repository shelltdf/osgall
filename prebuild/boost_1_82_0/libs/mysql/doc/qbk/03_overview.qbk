[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:overview Overview]
[nochunk]

[import ../../example/tutorial.cpp]

This section briefly explains the library main classes and functions, and how to use them.
The following diagram shows the interaction between the main classes in the library:

[$mysql/images/class_hierarchy.svg [align center]]

[section:connection Connection objects]

[reflink connection] is the library's "entry point". A connection is an I/O object, templated on
a [reflink Stream] type. A `connection` contains an instance of that `Stream` type and additional state required
by the protocol. `connection`'s constructor takes the same arguments as the underlying `Stream` constructor.

The library defines some typedefs to make things less verbose. The most common one is [reflink tcp_ssl_connection].
In this case, `Stream` is `boost::asio::ssl::stream<boost::asio::ip::tcp::socket>`,
which can be constructed from a `io_context::executor_type` and a `ssl::context`:

[tutorial_connection]

Typedefs for other transports are also available. See [link mysql.other_streams this section] for more info.

[endsect]

[section Connection establishment]

The MySQL client/server protocol is session-oriented. Before anything else, you must perform session
establishment, usually by calling [refmem connection connect]. This function performs two actions:

* It establishes the "physical" connection, by calling `connect()` on the underlying `Stream`
  object. For a [reflink tcp_ssl_connection], this establishes the TCP connection.
* It performs the handshake with the MySQL server. This is part of the MySQL client/server
  protocol. It performs authentication, sets session parameters like the default database
  to use, and performs the TLS handshake, if required.

[refmem connection connect] takes two parameters, one for each of the above actions:

* The physical endpoint where the server is listening. For TCP streams, this is a
  `boost::asio::ip::tcp::endpoint`. For UNIX sockets, it's a `boost::asio::local::stream_protocol::endpoint`.
  For TCP, we can resolve a string hostname and port to an endpoint using a `resolver` object.
* [reflink handshake_params] to use for the handshake operation. This parameter doesn't depend on the `Stream`
  type. See [link mysql.connparams this section] for more info.

[tutorial_connect]

Note that [refmem connection connect] can only be used with socket-like streams. If your stream
is not a socket, you must use the lower-level [refmem connection handshake] function. Please
read [link mysql.other_streams.non_sockets this section] for more info.

[endsect]

[section:queries_stmts Text queries and prepared statements]

The two main ways to use a connection are text queries and prepared statements:

[table
    [
        [Feature]
        [Used for...]
        [Code]
    ]
    [
        [
            Text queries: [refmem connection query].
        ]
        [
            Simple queries, without parameters:

                * `"START TRANSACTION"`
                * `"SET NAMES utf8"`
                * `"SHOW TABLES"`
            
        ]
        [
            ```
            resultset result;
            conn.query("START TRANSACTION", result);
            ```
        ]
    ]
    [
        [
            Prepared statements: [refmem connection prepare_statement], [refmem statement execute].
        ]
        [
            Queries with parameters unknown at compile-time.
        ]
        [
            ```
            tcp_ssl_statement stmt;
            conn.prepare_statement("SELECT first_name FROM employees WHERE company_id = ? AND salary > ?", stmt);

            resultset result;
            stmt.execute(std::make_tuple("HGS", 30000), result);
            ```
        ]
    ]
]

When you execute a text query or a prepared statement, you get a `resultset` object, which will be the subject
of the next section. We will delve deeper into prepared statements [link mysql.overview.statements later].

[endsect]

[section Resultsets]

In MySQL, a ['resultset] referes to the results generated by a SQL query. The [reflink resultset] class
is an in-memory reprentation of a MySQL resultset. The following diagram shows an approximate representation
of what a resultset looks like:

[$mysql/images/resultset.svg [align center] [scale 125]]

We can see that a resultset is composed of three pieces of information:

* The actual rows generated by the SQL query: [refmem resultset rows]. We'll expand on this later.
* Metadata about the columns retrieved by the query: [refmem resultset meta].
* Additional information about the query execution, like the number of affected rows ([refmem resultset affected_rows])
  or the number of warnings generated by the query ([refmem resultset warning_count]).

You can obtain a `resultset` by executing a text query ([refmem connection query]) or a prepared statement
([refmem statement execute]).

All SQL statements generate resultsets. Statements that generate no rows, like `INSERT`s, generate empty resultsets
(i.e. `result.rows().empty() == true`). The interface to execute `SELECT`s and `INSERT`s is the same.

[endsect]

[section Rows and fields]

We saw that [refmem resultset rows] returns a matrix-like data structure containing the rows
retrieved by SQL query. This library defines six data structures to represent MySQL data:

[variablelist
    [
        [[reflink field]]
        [The smallest unit of data. A single "cell" in a MySQL table. This is an owning, variant-like type.]
    ]
    [
        [[reflink field_view]]
        [Like `field`, but non-owning.]
    ]
    [
        [[reflink row]]
        [An owning, `vector`-like collection of fields.]
    ]
    [
        [[reflink row_view]]
        [Like `row`, but non-owning.]
    ]
    [
        [[reflink rows]]
        [An owning, matrix-like collection of fields. Represents several rows of the same size in an optimized way.]
    ]
    [
        [[reflink rows_view]]
        [Like `rows`, but non-owning.]
    ]
]

[refmem resultset rows] returns a [reflink rows_view] object. The memory for the rows is owned by the
`resultset` object. Indexing the returned view also returns view objects:

```
    // Populate a resultset object
    resultset result;
    conn.query("SELECT 'Hello world'", result);

    // resultset::rows() returns a rows_view. The underlying memory is owned by the resultset
    rows_view all_rows = result.rows();

    // Indexing a rows_view yields a row_view. The underlying memory is owned by the resultset
    row_view first_row = all_rows.at(0);

    // Indexing a row_view yields a field_view. The underlying memory is owned by the resultset
    field_view first_field = first_row.at(0); // Contains the string "Hello world"
```

Views behave similarly to `std::string_view`. You must make sure that you don't use a view after the
storage its points to has gone out of scope. In this case, you must not use any of the views after the
`resultset` object has gone out of scope.

As it happens with `std::string_view`, you can take ownership of a view using its owning counterpart:

```
    // You may use all_rows_owning after result has gone out of scope
    rows all_rows_owning {all_rows};

    // You may use first_row_owning after result has gone out of scope
    row first_row_owning {first_row};

    // You may use first_field_owning after result has gone out of scope
    field first_field_owning {first_field};
```

[endsect]

[section:fields Using fields]

[reflink field] and [reflink field_view] are specialized variant-like types that can hold any type
you may find in a MySQL table. Once you obtain a field, you can access its contents using the following functions:

* You can query a field's type by using [refmemunq field_view kind],
  which returns a [reflink field_kind] enum.
* You can query whether a field contains a certain type with `field::is_xxx`.
* You can get the underlying value with `field::as_xxx` and `field::get_xxx`.
  The `as_xxx` functions are checked (they will throw an exception if the
  actual type doesn't match), while the `get_xxx` are unchecked (they result
  in undefined behavior on type mismatch).
* You can stream and compare fields for equality.

For example:

```
    resultset result;
    conn.query("SELECT \"abc\", 42", result);

    // Using the is_xxx and get_xxx accessors
    field_view f = result.rows().at(0).at(0); // f points to the string "abc"
    if (f.is_string())
    {
        // we know it's a string, unchecked access
        string_view s = f.get_string();
        std::cout << s << std::endl; // Use the string as required
    }
    else
    {
        // Oops, something went wrong - schema msimatch?
    }

    // Using the as_xxx accessor
    f = result.rows().at(0).at(1);
    std::int64_t value = f.as_int64(); // Checked access. Throws if f doesn't contain an int
    std::cout << value << std::endl; // Use the int as required
```

`NULL` values are represented as field objects having `kind() == field_kind::null`.
You can check whether a value is `NULL` or not using [refmemunq field_view is_null].
In the following snippet, the `salary` column was defined as a nullable `double`.
This is how `NULL`s are typically handled:

```
    resultset result;
    conn.query(R"%(
        SELECT 0 AS product_id, 'potatoes' as description UNION
        SELECT 1, NULL UNION
        SELECT 2, 'carrots'
    )%", result);

    for (row_view r : result.rows())
    {
        field_view description_fv = r.at(1);
        if (description_fv.is_null())
        {
            // Handle the NULL value
            // Note: description_fv.is_string() will return false here; NULL is represented as a separate type
            std::cout << "No description for product_id " << r.at(0) << std::endl;
        }
        else
        {
            // Handle the non-NULL case. Get the underlying value and use it as you want
            // If there is any schema mismatch (and description was not defined as VARCHAR), this will throw
            string_view description = description_fv.as_string();

            // Use description as required
            std::cout << "product_id " << r.at(0) << ": " << description << std::endl;
        }
    }
```

Every MySQL type is mapped to a single C++ type. The following table shows these mappings:

[table
    [
        [`field_kind`]
        [C++ type]
        [MySQL types]
        [`is` accessor]
        [`as` accessor]
        [`get` accessor]
    ]
    [
        [`int64`]
        [`std::int64_t`]
        [Signed `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`]
        [[refmemunq field_view is_int64]]
        [[refmemunq field_view as_int64]]
        [[refmemunq field_view get_int64]]
    ]
    [
        [`uint64`]
        [`std::uint64_t`]
        [Unsigned `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`, `YEAR`, `BIT`]
        [[refmemunq field_view is_uint64]]
        [[refmemunq field_view as_uint64]]
        [[refmemunq field_view get_uint64]]
    ]
    [
        [`string`]
        [
            [reflink string_view] for `field_view`
            
            `std::string` for `field`
        ]
        [`CHAR`, `VARCHAR`, `TEXT`, `ENUM`, `SET`, `DECIMAL`]
        [[refmemunq field_view is_string]]
        [[refmemunq field_view as_string]]
        [[refmemunq field_view get_string]]
    ]
    [
        [`blob`]
        [
            [reflink blob_view] for `field_view`
            
            [reflink blob] for `field`
        ]
        [`BINARY`, `VARBINARY`, `BLOB`, `GEOMETRY`]
        [[refmemunq field_view is_blob]]
        [[refmemunq field_view as_blob]]
        [[refmemunq field_view get_blob]]
    ]
    [
        [`float_`]
        [`float`]
        [`FLOAT`]
        [[refmemunq field_view is_float]]
        [[refmemunq field_view as_float]]
        [[refmemunq field_view get_float]]
    ]
    [
        [`double_`]
        [`double`]
        [`DOUBLE`]
        [[refmemunq field_view is_double]]
        [[refmemunq field_view as_double]]
        [[refmemunq field_view get_double]]
    ]
    [
        [`date`]
        [[reflink date]]
        [`DATE`]
        [[refmemunq field_view is_date]]
        [[refmemunq field_view as_date]]
        [[refmemunq field_view get_date]]
    ]
    [
        [`datetime`]
        [[reflink datetime]]
        [`DATETIME`, `TIMESTAMP`]
        [[refmemunq field_view is_datetime]]
        [[refmemunq field_view as_datetime]]
        [[refmemunq field_view get_datetime]]
    ]
    [
        [`time`]
        [[reflink time]]
        [`TIME`]
        [[refmemunq field_view is_time]]
        [[refmemunq field_view as_time]]
        [[refmemunq field_view get_time]]
    ]
    [
        [`null`]
        []
        [Any of the above, when they're `NULL`]
        [[refmemunq field_view is_null]]
        []
        []
    ]
]

[link mysql.fields This section] contains more information about how the library maps
MySQL types to C++ types.

[endsect]

[section:statements Using prepared statements]

Until now, we've used simple text queries that did not contain any user-provided input.
In real world, most queries will contain some piece of user-provided input.

One approach could be to use string concatenation to construct a SQL query from user input,
and then execute it using `query()`. Avoid this approach as much as possible, as it can lead
to [*SQL injection vulnerabilities]. Instead, [*use prepared statements].

Prepared statements are server-side objects that represent a parameterized query. A statement is
represented in this library using the [reflink statement] template class. `statement` is a proxy I/O
object, as it references the `connection`'s stream and uses it for communication with the server.
Thus, you must keep the `connection` alive while you're using the statements it created.

Let's say you've got an inventory table, and you're writing a command-line program to get products
by ID. You've got the following table definition:

```
    resultset result;
    conn.query(R"%(
        CREATE TEMPORARY TABLE products (
            id VARCHAR(50) PRIMARY KEY,
            description VARCHAR(256)
        )
    )", result);
    conn.query("INSERT INTO products VALUES ('PTT', 'Potatoes'), ('CAR', 'Carrots')", result);
```

You can prepare a statement to retrieve products by ID using:

```
    tcp_ssl_statement stmt;
    conn.prepare_statement("SELECT description FROM products WHERE id = ?", stmt);
```

[reflink tcp_ssl_statement] is a typedef for the `statement` class to make code less verbose.

You can execute the statement using [refmem statement execute]:

```
    // Obtain the product_id from the user. product_id is untrusted input
    const char* product_id = argv[2];

    stmt.execute(std::make_tuple(product_id), result);
    // Use result as required
```

You must pass as many actual parameters as `?` placeholders the statement has, as a `std::tuple`.

To learn more about prepared statements, please refer to [link mysql.prepared_statements this section].

[endsect]

[section Multi-function operations]

Until now, we've been using [refmem connection query] and [refmem statement execute], which send
an execution request to the server, read the response and all generated data into an in-memory `resultset` object.

Some use cases may not fit in this simple pattern. For example:

* When reading a very big resultset, it may not be efficient (or even possible) to completely
  load it in memory. Reading rows in batches may be more adequate.
* If rows contain very long `TEXT` or `BLOB` fields, it may not be adequate to copy these values
  from the network buffer into a `resultset`. A view-based approach may be better.

For these cases, we can break the `query()` or `execute()` operation into several steps,
in a ['multi-function operation] (the term is coined by this library). This example reads an entire
table row by row, which can be the case in an ETL process:

```
    // Create the table and some sample data
    // In a real system, body may be megabaytes long.
    resultset result;
    conn.query(R"%(
        CREATE TEMPORARY TABLE posts (
            id INT PRIMARY KEY AUTO_INCREMENT,
            title VARCHAR (256),
            body TEXT
        )
    )%", result);
    conn.query(R"%(
        INSERT INTO posts (title, body) VALUES
            ('Post 1', 'A very long post body'),
            ('Post 2', 'An even longer post body')
    )%", result);

    // execution_state stores state about our operation, and must be passed to all functions
    execution_state st;

    // Writes the query request and reads the server response, but not the rows
    conn.start_query("SELECT title, body FROM posts", st);

    // post will be populated by read_one_row. When all rows have been read,
    // read_one_row returns false
    row post:
    while (conn.read_one_row(st, post))
    {
        boost::string_view title = post.at(0).as_string();
        boost::string_view body = post.at(0).as_string();
        // use title and body as required
    }
```

[warning
    Once you start a multi-function operation with [refmem connection start_query] or [refmem statement start_execution],
    the server immediately sends all rows to the client. [*You must read all rows] before engaging in further operations.
    Otherwise, you will encounter packet mismatches, which can lead to bugs and vulnerabilities!
]

Multi-function operations are powerful but complex. Only use them when there is a strong reason to do so.
Please refer to [link mysql.multi_function this section] for more information on these operations.

[endsect]

[section:async Asynchronous functions and multi-threading]

The library offers asynchronous versions of each operation involving network transfers.
Following Asio's convention, these are named `async_xxx` (e.g. [refmem connection async_query]).
They follow Asio's async model, so they can be used with any `CompletionToken`, including callbacks
and coroutines. [link mysql.async This section] provides more info on this topic.

[h4 Single read and write per connection]

As mentioned, `connection` holds an internal `Stream` that is used for network transfers.
All network operations involve stream [*reads], stream [*writes], or [*both]. At any given point in time, for
a single connection, [*only one read and one write operation may be outstanding]. Invoking several
reads or writes in parallel for a single connection results in undefined behavior. All network functions
document whether they perform reads, writes or both.

For example, [refmem connection async_query] performs both reads and writes.
Doing this is illegal and should be avoided:

```
    // Coroutine body
    // DO NOT DO THIS!!!!
    resultset result1, result2;
    auto q1 = conn.async_query("SELECT 1", result1, use_awaitable);
    auto q2 = conn.async_query("SELECT 2", result2, use_awaitable);
    co_await (q1 && q2);
```

If you need to perform queries in parallel, open more connections to the server.

[h4 Proxy I/O objects]

As mentioned, `statement` is a proxy I/O object: it uses the stream created by the
`connection` to perform the required I/O. This means that [*read and write operations invoked
on statements also count toward the `connection` maximum]. This is illegal, too:

```
    // Coroutine body
    resultset result1, result2;
    tcp_ssl_statement stmt;
    conn.prepare_statement("SELECT ?", stmt);

    // Invokes two read and write operations in parallel on the same stream
    // DO NOT DO THIS!!!
    auto aw1 = conn.async_query("SELECT 1", result1, use_awaitable);
    auto aw2 = stmt.async_execute(std::make_tuple(42), result2, use_awaitable);
    co_await (aw1 && aw2);
```

If you're working in a multi-threading environment, please bear in mind that
[*network operations invoked on `statement`s also mutate the
`connection`] that created them. Use strands as required to avoid race conditions.

[endsect]

[endsect]
